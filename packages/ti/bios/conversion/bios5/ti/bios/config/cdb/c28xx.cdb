/*
 *  Do not modify this file; it's generated from c28xx.cdb.h
 *  via mkseed!
 */

//# c28xx.cdb 5.25.34
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
object M0SARAM :: MEM {
    param iAllocHeap ::1
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "USER"
    param base :: 0x00000000
    param len ::  0x00000800
    param space :: "data"
}
 
object L0SARAM :: MEM {
    param iAllocHeap :: 1
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "USER"
    param base :: 0x00008000
    param len ::  0x00002000
    param space :: "data"
}
 
object OTP :: MEM {
    param iAllocHeap :: 0
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "USER"
    param base :: 0x003D7800
    param len ::  0x00000400
    param space :: "code"
}
 
object FLASH :: MEM {
    param iAllocHeap :: 0
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "USER"
    param base :: 0x003D8000
    param len ::  0x0001FFF6
    param space :: "code"
} 
object H0SARAM :: MEM {
    param iAllocHeap :: 0 
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "USER"
    param base :: 0x003F8000
    param len ::  0x00002000
    param space :: "code"
}
 
object BOOTROM :: MEM {
    param iAllocHeap :: 0 
    param iId :: 0
    param iIsUsed :: 1                   
    param iDelUser :: "USER"
    param base :: 0x003FF000
    param len ::  0x00000fc0
    param space :: "code"
}
object PIEVECT :: MEM {
    param iComment :: .iDelMsg
    param iAllocHeap ::0
    param iId ::0
    param iIsUsed ::1
    param iDelUser :: "MEM"
    param iDelMsg :: (
        " This Object defines space for the PIE interrupt vectors and can't be deleted"
    )
    param base  :: 0x00000D00
    param len :: 0x00000100
    param space :: "data"
}
 
 
 
 
 
 
 
 
 
 
 
 
class Module {
    prop Visible :: 1
    prop Writable :: 1
    prop IsConfMod :: (
	.gNumOf > 0 ? 1 : 0
    )
    prop NoGen	::  0
    prop IsDirty ::  (
	$a = .gDirty,
	.gDirty = 0,
	$a
    )
    
 
    prop dataSize :: 0
    
    
 
    prop error :: #(
	"Error: ", .name,
	$1
    )
    
 
    prop warning :: (
	"Warning ...", .name,
	$1
    )
    
 
    prop minBit	:: (
	$a = 0,
	while (($1 & (1 << $a)) && $a < 32) {
	    ++$a
	},
	$a
    )
    
    
 
    prop name :: (
	"<unnamed module>"
    )
    
 
    prop numBit :: (
	$a = $b = 0,
	while ($a < 32) {
	    if ($1 & (1 << $a)) {
		++$b
	    }
	},
	$b
    )
    
    
 
    global gInit ::= (
	$a = 0,
	$b = 0,
	scan ($i; self) {
	    if ($i.IsConfObj()) {
		$a += 1,
		if (self.isFinite) {
		    $b |= 1 << $i.iId
		}
	    }
	},
	.gNumOf = $a,
	.gSetOf = $b,
	if (.gInitFlag == 0) {
	    .localInit()
	},
	.gInitFlag = 1
    ) {
	prop Visible :: 0    
	prop Writable :: 0
	prop NoGen :: 1	     
    }
    global gInitFlag :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gDirty :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global  gNumOf :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gSetOf :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    global  gUser :: "USER" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
 
class ObjectMgr {
    isa	    Module
    
 
    prop CanCreate :: (
	if (.gNumOf < .maxObjs()) {
	    .localCanCreate()
	}
	else {
	    .warning("Maximum number of objects already created")
	}
    )
    
    
 
    prop CanDelete :: (
	if (.iDelMsg == "ok" || (.iDelUser == .gUser)) {
	    if (.iId >= 0 && .iIsUsed) {
		.localCanDelete()
	    }
	    else {
		.warning("Object already deleted")
	    }
	}
	else {
	    .warning(.iDelMsg)
	}
    )
    
    
 
    prop Create	:: (
	(.gUser = ($0 > 0 ? $1 : "USER")),
	if (($a = .CanCreate()) == "ok") {
	    if (($a = .localCreate()) == "ok") {
		if (.iIsUsed == 0) {
		    .mkId($0 > 1 ? $2 : -1),
		    .iIsUsed = 1,
		    GlobalStatus.gDirty = 1,
		    .gDirty = 1
		}
	    }
	},
	(.gUser = "USER"),
	$a
    )
    
 
    prop Delete :: (
	(.gUser = ($0 > 0 ? $1 : "USER")),
	if (($a = .CanDelete()) == "ok") {
	    if (($a = .localDelete()) == "ok") {
		.rmId(.iId),
		.iIsUsed = 0,
		GlobalStatus.gDirty = 1,
		.gDirty = 1
	    }
	},
	(.gUser = "USER"),
	$a
    )
    
    
 
    prop GetSetOf :: (
	.gSetOf
    )
    
    
 
    prop GetNumOf :: (
	.gNumOf
    )
    
    
 
    prop GetObjId :: (
	.iId
    )
    
 
    prop GetPriority :: (
	.iId
    )
    
    
 
    prop SetPriority :: (
	.iId = $1
    )
    
    
 
    prop IsConfObj ::  (
	.iIsUsed
    )
    
 
    prop localCanCreate :: (
	"ok"
    )
    
 
    prop localCanDelete :: (
	"ok"
    )
    
 
    prop localCreate :: (
	"ok"
    )
    
 
    prop localDelete :: (
	"ok"
    )
    
    
 
    prop localInit :: (
	0
    )
    
    
 
    prop isFinite :: (
	.maxObjs() <= GBL.DSPWORDSIZE ? 1 : 0
    )
    
    
 
    prop mkId ::  (
	if (.isFinite()) {
	    if ($1 < 0) {
		.iId = .minBit(.gSetOf)
	    }
	    else {
		.iId = $1
	    },
	    (.gSetOf |= (1 << .iId))
	}
	else {
	    .iId = 0
	},
	++.gNumOf,
	.iId
    )
    
    
 
    prop rmId :: (
	if (.isFinite()) {
	    .gSetOf &= ~(1 << .iId)
	},
	--.gNumOf
    )
    
    
 
    prop maxObjs :: (
	GBL.DSPWORDSIZE
    )
    
 
    prop isDriver :: (
	0
    )
    
 
    prop SortChildHierView :: (
	1
    )
    inst iDelMsg :: "ok" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst iDelUser :: "USER" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iId :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iIsUsed :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
     
    inst iComment :: .iDelUser == "USER" ? "<add comments here>" : .iDelMsg {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "comment"
	prop JSName :: "comment"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER" ? 1 : 0
	prop NoGen :: 1
    }
}
				 
				 
				 
				 
				 
				 
				 
				 	
				 
				 
				 
				 
				 
				 
				 
				 
				  
				 
				 
				 
 
type GlobalStatus {
    prop NoGen :: 1
    prop Visible :: 0
    prop Writable :: 0
    prop Label :: "Current Configuration Status"
    prop GlobalIcon :: 101
    prop InstanceIcon :: 101
    prop GlobalHelpTopic :: (
	100
    )
    prop GlobalPropertyPage :: (
	"{9D3AD931-847B-11d0-A621-0000C070F3E9}"
    )
    global GENLIB :: "bioscfg.dll" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generation Library"
	prop NoGen :: 1
	prop Visible :: 0
	prop Writable :: 1
    }
    
    global DATE :: "" {		 
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global GCONFVERS :: "" {	 
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global SysDataSize ::= (
	$a = 0,
	scan ($i; nil) {		    
	    if ($i.dataSize() != nil) {	    
		$a = $a + $i.dataSize()	    
	    }
	},
	$a
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "Estimated Data Size: %d"
	prop StatusField :: 1
	prop NoGen :: 1
    }
    global MinStackSize ::= (
	$a = ((2) + (((2) + (4) + (2) + (2)))),	    
	$a = $a + ((1) + (((2) + (4) + (2) + (2)))),	    
	$a = $a + (0),	    
	$b = 0,
	scan ($i; CLK) {	    
	    if ($i.IsConfObj()) {
		$b |= 1
	    }
	},
	$a = $a + (((((5) + (2) + (12) + (14))) + (2) + (((2) + (4) + (2) + (2)))) * $b), 
	$b = 0,
	scan ($i; HWI) {	    
	    if ($i.IsConfObj()) {   
		if ($i != HWI_RESET) {
		    if (($i.function != @HWI_unused) && ($i.function != @RESERVED)) {
			$b++
		    }
		}
	    }
	},
	$a = $a + (((2) + (10) + (6)) * $b),    
	$b = 0,
	scan ($i; SWI) {	    
	    if ($i.IsConfObj()) {   
		if ($i.priority > $b) {
		    $b = $i.priority
		}
	    }
	},
	$a = $a + (((((2) + (10) + (6))) + (((((5) + (2) + (12) + (14))) + (2))) + (((6) + (((2) + (4) + (2) + (2)))))) * $b), 
	$b = 0,
	scan ($i; PRD) {	    
	    if ($i.IsConfObj()) {
		$b |= 1
	    }
	},
	$a = $a + (((2) + (((2) + (4) + (2) + (2)))) * $b), 
	$a
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "Est. Min. Stack Size (MAUs): %d"
	prop StatusField :: 1
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ConfigWarnings ::= (
	if (.MinStackSize > MEM.STACKSIZE) {
	    "Application stack size is too small; decrease the number of SWI priorities or increase the stack in MEM."
	}
	else {
	    "None"
	}
    ) {
	prop Label :: "Warnings"
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global SeedVersion ::= "@(#)*** cuda-u34x" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global gDirty :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    prop Status :: (#.SeedVersion, #.MinStackSize, #.SysDataSize)
}
 
class EModule {
    isa Module
    prop IsXMod :: (
        1
    )
    prop Vendor :: (
	""
    )
    prop Version :: (
	""
    )
}
 
class EObjectMgr {
    isa ObjectMgr
    prop IsXMod :: (
        1
    )
    prop Vendor :: (
        ""
    )
    prop Version :: (
        ""
    )
}
 
class ModuleFolder {
    isa Module
    prop NoGen :: 1
}
 
type SYSTEM {
    isa ModuleFolder
    prop Label :: "System"
    prop GlobalIcon :: 151
    prop GlobalHelpTopic :: (
	500
    )
    prop GlobalPropertyPage :: (
	"{B936FB91-52A5-11d4-947C-0050048381B7}"
    )
}
type INS {
    isa ModuleFolder
    prop Label :: "Instrumentation"
    prop GlobalIcon :: 152
    prop GlobalHelpTopic :: (
	501
    )
    prop GlobalPropertyPage :: (
	"{053C8F90-52A6-11d4-947C-0050048381B7}"
    )
}
type SCH {
    isa ModuleFolder
    prop Label :: "Scheduling"
    prop GlobalIcon :: 153
    prop GlobalHelpTopic :: (
	502
    )
    prop GlobalPropertyPage :: (
	"{053C8F91-52A6-11d4-947C-0050048381B7}"
    )
}
type SYN {
    isa ModuleFolder
    prop Label :: "Synchronization"
    prop GlobalIcon :: 154
    prop GlobalHelpTopic :: (
	503
    )
    prop GlobalPropertyPage :: (
	"{053C8F92-52A6-11d4-947C-0050048381B7}"
    )
}
type IOF {
    isa ModuleFolder
    prop Label :: "Input/Output"
    prop GlobalIcon :: 155
    prop GlobalHelpTopic :: (
	504
    )
    prop GlobalPropertyPage :: (
	"{053C8F93-52A6-11d4-947C-0050048381B7}"
    )
}
type SIODRIVER {
    isa ModuleFolder
    prop Label :: "Device Drivers"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 127
    prop GlobalHelpTopic :: (
        505
    )
    prop GlobalPropertyPage :: (
        "{A2BCEC70-5365-11d4-947C-0050048381B7}"
    )
}
 
 
type PROJ {
    isa  ObjectMgr
    prop name :: "PROJ"
    prop maxObjs :: 0	 
    prop Label :: "Project Manager"
    prop GlobalIcon :: 121
    prop InstanceIcon :: 122
    prop InstanceHelpTopic :: (
	201
    )
    
    prop GlobalHelpTopic :: (
	101
    )
    prop InstancePropertyPage :: (
	"{AC3C77D1-890B-11d0-A621-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{AC3C77D2-890B-11d0-A621-0000C070F3E9}"
    )
    prop NoGen :: 1
    prop Visible :: 0
    
    global ALIASALL :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Generate C Names for All Objects"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global IGNOREWARNING :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Ignore Warnings"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global LIBPATH :: ".;../../lib;$(BIOSROOT)/lib" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Library Search Path"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global INCPATH :: ".;../../include;$(BIOSROOT)/include" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Include File Search Path"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global OBJDIR :: "." {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Object file directory"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    global EXTEXE :: "out" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Executable File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTLIB :: "lib" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Library File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTASM :: "asm" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Assembly Language Source File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global EXTOBJ :: "obj" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Object File Extension"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst projType ::  "Executable" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Executable,Library"
	prop Label :: "Target Type"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst projName :: "$(PROG)" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Target File Name"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst useRpt :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use RPT Instruction"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst minimizeSpace :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Optimize for Space over Time"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst tmx :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Avoid TMX Silicon Bugs"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
}
type PROJ_FILE {
    isa ObjectMgr
    prop Visible :: 0
    
    prop Label :: "Project File Manager"
    
 
    prop InstanceHelpTopic :: (
	BIOSHELP_PROJ_FILE_INSTANCE
    )
    
    prop GlobalHelpTopic :: (
	BIOSHELP_PROJ_FILE_GLOBAL
    )
    prop InstancePropertyPage :: (
	"{AC3C77D3-890B-11d0-A621-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{AC3C77D4-890B-11d0-A621-0000C070F3E9}"
    )
    prop NoGen :: 1
    
    inst elemType ::  "C Source" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "C Source,ASM Source,Library,Linker Command File"
	prop Label :: "Input File Type"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst elemName :: "$(PROG)" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Input File Name"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst optLevel :: "register+local+global" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "register,register+local,register+local+global,register+local+global+file"
	prop Label :: "Optimization Level"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst inline :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Inline Expansion"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst definitions :: "" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Additional Definitions"
	prop Visible :: 0
	prop Writable :: .elemType == "C Source" ? 1 : 0
	prop NoGen :: 1
    }
    inst iParent :: 0 {
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
}
 
type GBL {
    isa Module
    prop name :: "GBL"
    prop Label :: "Global Settings"
    prop IsContainedIn :: SYSTEM
    prop cGen :: 0
    prop GenLinkPrologue :: (
            "%10S\nSECTIONS {%4t\n.vers (COPY): {} /* version information */%0t\n}\n\n-priority\n%1S-l%2S%3S\n%15S%4S%16S%5S%6S%7S\0, _autoInitStr, _board, _librarySuffix, _devLibStr, _biosLibStr, _rtdxLibStr, _rtsLibStr, _librarySuffix, _compilerModel, _lnkCmdStr, _lnkCmdFile, _cslLibStr, _chipType, _librarySuffix, _chipStr, _sioLibStr, _rtsNameStr"
    )
    
 
    prop ConfigurationClass :: "{2779A121-92CC-11d1-A63D-0000C070F3E9}"
    prop GlobalIcon :: 105
    prop InstanceIcon :: 106
        
    prop GlobalHelpTopic :: (
        103
    )
    prop InstanceHelpTopic :: (
        103
    )
    prop InstancePropertyPage :: (
        "{B7240DE4-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
        "{B7240DE5-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop localInit :: (
        RTA_toHost.Create("HST"),
        RTA_toHost.bufseg = HST.OBJMEMSEG,
        RTA_fromHost.Create("HST"),
        RTA_fromHost.bufseg = HST.OBJMEMSEG,
        RTA_dispatcher.Create("HST"),
        IDL_busyObj.Create("IDL"),
        IDL.USEIDLBUSYOBJ = 1,
        IDL_cpuLoad.Create("IDL")
    )
    
    prop chipcall :: (
        "ok"
    )
    prop IsConfMod :: 1          
    prop ucompare :: (
      $e = "ok",
      $a = ($1 >> 31) & 0x00000001,
      $b = ($2 >> 31) & 0x00000001,
      $c = $1 & 0x7fffffff,
      $d = $2 & 0x7fffffff,
      if($a > $b) {
        $e = "gt"
      }
      else {
        if($a == $b) {
          if($c > $d) {
            $e = "gt"
          }
          else {
            if($c == $d) {
              $e = "eq"
            }
            else {
              $e = "lt"
            }
          }
        }
        else {
          $e = "lt"
        }
      },
      $e
    )
    
    
 
    prop L2Check :: (
        if (.DSPSUBTYPE == 6211 || .DSPSUBTYPE == 6711) {
            .PCC = "mapped",             
            if (.C641XL2CONFIGURE == 1) {
                .C641XL2CONFIGURE = 0,
                .L2CONFIGALLOC = 0
            },
            .L2CacheSizeCheck()
        }
        else {
            if (.DSPSUBTYPE == 6400) {
                .PCC = "mapped",         
                if (.C621XL2CONFIGURE == 1) {
                    .C621XL2CONFIGURE = 0
                },
                .L2CacheSizeCheck()
            }
            else {
                if (.C621XL2CONFIGURE == 1) {
                    .C621XL2CONFIGURE = 0,
                    .L2CacheSizeCheck()
                }
                else {
                    if (.C641XL2CONFIGURE == 1) {
                        .C641XL2CONFIGURE = 0,
                        .L2CONFIGALLOC = 0,
                        .L2CacheSizeCheck()
                    }
                }
            }
        }
    )
    prop C621xL2CacheSizeCheck :: (
        $e = "ok",
        $a = CACHE_L2.base,
        $b = CACHE_L2.len,
        if ( .C621XL2CONFIGURE == 0 ) {
            CACHE_L2.Delete("MEM")
        }
        else {
            if (.L2MODEOPTS == "SRAM" ) {
                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len,
                CACHE_L2.len = 0x0,
                CACHE_L2.Delete("MEM")
            }
            else {
                if (.L2MODEOPTS == "1-way cache" ) {
                    CACHE_L2.Create("MEM"),
                    CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x4000,
                    CACHE_L2.len = 0x4000
                }
                else {
                    if (.L2MODEOPTS == "2-way cache" ) {
                        CACHE_L2.Create("MEM"),
                        CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000,
                        CACHE_L2.len = 0x8000
                    }
                    else {
                        if (.L2MODEOPTS == "3-way cache" ) {
                            CACHE_L2.Create("MEM"),
                            CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0xc000,
                            CACHE_L2.len = 0xc000
                        }
                        else {
                            if (.L2MODEOPTS == "4-way cache" ) {
                                CACHE_L2.Create("MEM"),
                                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000,
                                CACHE_L2.len = 0x10000
                            }
                        }
                    }
                }
            }
        },
        $e
    )
    
    prop C641xL2CacheSizeCheck :: (
        $e = "ok",
        $a = CACHE_L2.base,
        $b = CACHE_L2.len,
        if ( .C641XL2CONFIGURE == 0 ) {
            CACHE_L2.Delete("MEM")
        }
        else {
            if (.C641XL2MODEOPTS == "4-way cache (0k)" ) {
                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0,
                CACHE_L2.len = 0x0,
                CACHE_L2.Delete("MEM")
            }
            else {
                if (.C641XL2MODEOPTS == "4-way cache (32k)" ) {
                    CACHE_L2.Create("MEM"),
                    CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000,
                    CACHE_L2.len = 0x8000
                }
                else {
                    if (.C641XL2MODEOPTS == "4-way cache (64k)" ) {
                        CACHE_L2.Create("MEM"),
                        CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000,
                        CACHE_L2.len = 0x10000
                    }
                    else {
                        if (.C641XL2MODEOPTS == "4-way cache (128k)" ) {
                            CACHE_L2.Create("MEM"),
                            CACHE_L2.base = CACHE_L2.base + CACHE_L2.len
                                - 0x20000,
                            CACHE_L2.len = 0x20000
                        }
                        else {
                            if (.C641XL2MODEOPTS == "4-way cache (256k)" ) {
                                CACHE_L2.Create("MEM"),
                                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len
                                    - 0x40000,
                                CACHE_L2.len = 0x40000
                            }
                        }
                    }
                }
            }
        },
        $e
    )
    
    prop C64PL1PCacheSizeCheck :: (
        $e = "ok",
        if (.C64PL2CONFIGURE == 0) {
            .C64PL1PCFG = "32k",
            CACHE_L1P.Create("MEM"),
            CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000,
            CACHE_L1P.len = 0x8000
        }
        else {
            if (.C64PL1PCFG == "0k") {
              CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x0,
              CACHE_L1P.len = 0x0,
              CACHE_L1P.Delete("MEM")
            }
            else {
              if (.C64PL1PCFG == "4k") {
                CACHE_L1P.Create("MEM"),
                CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x1000,
                CACHE_L1P.len = 0x1000
              }
              else {
                if (.C64PL1PCFG == "8k") {
                  CACHE_L1P.Create("MEM"),
                  CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x2000,
                  CACHE_L1P.len = 0x2000
                }
                else {
                  if (.C64PL1PCFG == "16k") {
                    CACHE_L1P.Create("MEM"),
                    CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x4000,
                    CACHE_L1P.len = 0x4000
                  }
                  else {
                    if (.C64PL1PCFG == "32k") {
                      CACHE_L1P.Create("MEM"),
                      CACHE_L1P.base = CACHE_L1P.base + CACHE_L1P.len - 0x8000,
                      CACHE_L1P.len = 0x8000
                    }
                    else {
                        $e = .error("Unknown cache size")
                    }
                  }
                }
              }
            }
        },
        $e
    )
    prop C64PL1DCacheSizeCheck :: (
        $e = "ok",
        if (.C64PL2CONFIGURE == 0) {
            .C64PL1DCFG = "32k",
            CACHE_L1D.Create("MEM"),
            CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000,
            CACHE_L1D.len = 0x8000
        }
        else {
            if (.C64PL1DCFG == "0k") {
              CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x0,
              CACHE_L1D.len = 0x0,
              CACHE_L1D.Delete("MEM")
            }
            else {
              if (.C64PL1DCFG == "4k") {
                CACHE_L1D.Create("MEM"),
                CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x1000,
                CACHE_L1D.len = 0x1000
              }
              else {
                if (.C64PL1DCFG == "8k") {
                  CACHE_L1D.Create("MEM"),
                  CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x2000,
                  CACHE_L1D.len = 0x2000
                }
                else {
                  if (.C64PL1DCFG == "16k") {
                    CACHE_L1D.Create("MEM"),
                    CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x4000,
                    CACHE_L1D.len = 0x4000
                  }
                  else {
                    if (.C64PL1DCFG == "32k") {
                      CACHE_L1D.Create("MEM"),
                      CACHE_L1D.base = CACHE_L1D.base + CACHE_L1D.len - 0x8000,
                      CACHE_L1D.len = 0x8000
                    }
                    else {
                        $e = .error("Unknown cache size")
                    }
                  }
                }
              }
            }
        },
        $e
    )
    prop C64PL2CacheSizeCheck :: (
        $e = "ok",
        if (.C64PL2CONFIGURE == 0) {
            CACHE_L2.Delete("MEM")
        }
        else {
            if (.C64PL2MODEOPTS == "0k") {
              CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x0,
              CACHE_L2.len = 0x0,
              CACHE_L2.Delete("MEM")
            }
            else {
              if (.C64PL2MODEOPTS == "32k") {
                CACHE_L2.Create("MEM"),
                CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x8000,
                CACHE_L2.len = 0x8000
              }
              else {
                if (.C64PL2MODEOPTS == "64k") {
                  CACHE_L2.Create("MEM"),
                  CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x10000,
                  CACHE_L2.len = 0x10000
                }
                else {
                  if (.C64PL2MODEOPTS == "128k") {
                    CACHE_L2.Create("MEM"),
                    CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x20000,
                    CACHE_L2.len = 0x20000
                  }
                  else {
                    if (.C64PL2MODEOPTS == "256k") {
                      CACHE_L2.Create("MEM"),
                      CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x40000,
                      CACHE_L2.len = 0x40000
                    }
                    else {
		      if (.C64PL2MODEOPTS == "512k") {
                        CACHE_L2.Create("MEM"),
                        CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x80000,
                        CACHE_L2.len = 0x80000
                      }
		      else {
		        if (.C64PL2MODEOPTS == "1024k") {
                          CACHE_L2.Create("MEM"),
                          CACHE_L2.base = CACHE_L2.base + CACHE_L2.len - 0x100000,
                          CACHE_L2.len = 0x100000
                        }
                        else {
                          $e = .error("Unknown cache size")
                        }
                      }
                    }
                  }
                }
              }
            }
        },
        $e
    )
    prop L2CacheSizeCheck :: (
        $e = "ok",
        scan ($i; MEM) {
            if ($i == CACHE_L2) {
                .C621XL2CONFIGURE ?
                    $e = .C621xL2CacheSizeCheck() :
                .C641XL2CONFIGURE ?
                    $e = .C641xL2CacheSizeCheck() :
                .DSPSUBTYPE == 6211 || .DSPSUBTYPE == 6711 ?
                    $e = .C621xL2CacheSizeCheck() :
                .DSPSUBTYPE == 6400 ?
                    $e = .C641xL2CacheSizeCheck() : {
                        CACHE_L2.base = 0x0,
                        CACHE_L2.len = 0x0,
                        CACHE_L2.Delete("MEM")
                    }
            }
        },
        $e
    )
    global PRODUCT :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1       
        prop EnvField :: 1
    }
    
 
    global CALLBACKOBJ :: nil {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CHIPCHAIN :: nil {
        prop Visible ::0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global TRACE :: "CD-01234567" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Trace Mask"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 0
    }
    global BOARD :: "c28xx" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Target Board Name"
        prop JSName :: "BOARDNAME"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global ROM :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Link to ROM Library"
        prop Visible :: 0
        prop Writable :: 0 
        prop NoGen :: 0
    }
    global CPUCLOCK :: GBL.DSPTYPE == 62 ? .MIPS : .MIPS * 2 {
         
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PROCID :: = 0  {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x01
        prop Label :: "Processor ID (PROCID)"
        prop JSName :: "PROCID"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    
    global CLKIN :: = 20000  {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
        prop Label :: "Board Clock in KHz (Informational Only)"
        prop JSName :: "CLKIN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    global FREQ :: int(round(.MIPS * 1000)) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    
    global MIPS :: 150.0 {          
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Style :: 0x04
        prop Format :: "%.4f"
        prop Label :: "DSP Speed In MHz (CLKOUT)"
        prop JSName :: "CLKOUT"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
            $a = .MIPS,
            $b = (GBL.DSPTYPE == 62) ? $1 : $1 * 2,
            $e = "ok",
            .MIPS = $1,
            .FREQ = int(.MIPS * 1000),
            if (($e = .setCPUClock($b)) != "ok") {
                .MIPS = $a
            },
            $e
        )
    }
    prop setCPUClock :: (
        $e = "ok",
        if ($1 != .CPUCLOCK) {
            $a = .CPUCLOCK,
            .CPUCLOCK = $1,
            if (GBL.CALLBACKOBJ != nil) {
                $e = GBL.CALLBACKOBJ.call()
            },
            if ($e != "ok") {
                .CPUCLOCK = $a,
                GBL.CALLBACKOBJ.call()
            }
        },
        if ($e == "ok") {
            "ok"
        }
        else {
            .error($e)
        }
    )
    
    
 
    global OSTYPE :: "BIOS" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "BIOS"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
 
    global DSPTYPE :: 28 {            
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Major Type"
        prop JSName :: "DSPTYPE"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    
    global SPECIFYRTSLIB :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify RTS library"
        prop JSName :: "SPECIFYRTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: 1
    }
    
    global RTSLIB :: "" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Run-Time Support Library"
        prop JSName :: "RTSLIB"
        prop NoGen :: 1
        prop Visible :: 1
        prop Writable :: .SPECIFYRTSLIB
    }
    global DSPSUBTYPE :: 28 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Type"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    
    global CHIPTYPE :: "other"  {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "other"
        prop Label :: "Chip Support Library (CSL)"
        prop JSName :: "CHIPTYPE"
        prop NoGen :: 1
        prop Visible :: 0
        prop Writable :: 1
        prop Set :: (
            .CHIPTYPE = $1,
            $e = "ok",
            if (GBL.CHIPCHAIN != nil) {
                $e = GBL.CHIPCHAIN.chipcall()
            },
            $e
        )
    }
    global DISPCALLCSLCFGINIT ::= (
            .CHIPTYPE != "other" && .CHIPTYPE != "custom"
        ) {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call CSL_cfgInit Initialization routine"
        prop Visible :: 0
        prop Writable :: .SUPPORTCSL
        prop NoGen :: 1
    }
    global DSPNAME :: "c28xx" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global PLLTYPE :: "281x" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "281x,280x,2802x,2803x,2806x,282xx,283xx,2834x"
        prop Label :: "PLL Type"
        prop JSName :: "PLLTYPE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
            .PLLTYPE = $1,
            if ($1 == "281x") {
                .DSPSUBTYPE = 28100
            }
            else {
                if ($1 == "280x") {
                    .DSPSUBTYPE = 28000
                }
                else {
                    if ($1 == "282xx") {
                        .DSPSUBTYPE = 28200
                    }
                    else {
			if ($1 == "283xx") {
                            .DSPSUBTYPE = 28300
			}
			else {
			    if ($1 == "2802x" || $1 == "2803x") {
				.DSPSUBTYPE = 28020
			    }
			    else {
			        if ($1 == "2806x") {
				    .DSPSUBTYPE = 28060
			        }
			        else {
				    .DSPSUBTYPE = 28340
			        }
			    }
			}
                    }
                }            
            },
            "ok"
        )
    }
     
    global MODIFYPLLCR0 :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Initialize PLLCR (280x)"
        prop JSName :: "MODIFYPLLCR0"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 28000) ? 1 : 0
        prop TabName :: " 280x "
        prop NoGen :: 1
        prop Set :: (
            if ($1 != .MODIFYPLLCR0) {    
                .MODIFYPLLCR0 = $1,
                .MODIFYPLLCR = $1
            },
            "ok"
        )
    }
    global PLLCR0 :: 0x0A
    {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLCR Register value (280x)"
        prop JSName :: "PLLCR0"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 28000) ? .MODIFYPLLCR0 : 0
        prop TabName :: " 280x "
        prop NoGen :: 1
        prop Set :: (
            .PLLCR = $1,
            .PLLCR0 = $1,
            "ok"
        )
    }
     
    global USERLIMPMODEABORTFXN :: @_FXN_F_nop {
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User Limp Mode Abort Function (280x)"
        prop JSName :: "USERLIMPMODEABORTFXN"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 28000) ? .MODIFYPLLCR0 : 0
        prop TabName :: " 280x "
        prop NoGen :: 0
    }
     
    global MODIFYPLLCR1 :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Initialize PLLCR (281x)"
        prop JSName :: "MODIFYPLLCR1"
        prop Visible ::  1
        prop Writable ::(GBL.DSPSUBTYPE == 28100) ? 1 : 0
        prop TabName :: " 281x "
        prop NoGen :: 1
        prop Set :: (
            if ($1 != .MODIFYPLLCR1) {    
                .MODIFYPLLCR1 = $1,
                .MODIFYPLLCR = $1
            },
            "ok"
        )
    }
    global PLLCR1 :: 0x0A
    {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLCR Register value (281x)"
        prop JSName :: "PLLCR1"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 28100) ? .MODIFYPLLCR1 : 0
        prop TabName :: " 281x "
        prop NoGen :: 1
        prop Set :: (
            .PLLCR = $1,
            .PLLCR1 = $1,
            "ok"
        )
    }
    global PLLWAITCYCLE :: 131072
    {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format  :: "%d"
        prop Style :: 0x20
        prop Label :: "Cycles to wait for PLL lock (281x)"
        prop JSName :: "PLLWAITCYCLE"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 28100) ? .MODIFYPLLCR1 : 0
        prop TabName :: " 281x "
        prop NoGen :: 0
    }
     
    global MODIFYPLLCR2 :: 1
    {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Initialize PLLCR (282xx/283xx)"
        prop JSName :: "MODIFYPLLCR2"
        prop Visible ::  1
        prop Writable :: ((GBL.DSPSUBTYPE == 28200) || (GBL.DSPSUBTYPE == 28300)) ? 1 : 0
        prop TabName :: " 282xx / 283xx "
        prop NoGen :: 1
        prop Set :: (
            if ($1 != .MODIFYPLLCR2) {    
                .MODIFYPLLCR2 = $1,
                .MODIFYPLLCR = $1
            },
            "ok"
        )
    }
    global MODIFYPLLCR3 :: 1
    {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Initialize PLLCR (2802x/2803x/2806x)"
        prop JSName :: "MODIFYPLLCR3"
        prop Visible ::  1
        prop Writable :: ((GBL.DSPSUBTYPE == 28020) || (GBL.DSPSUBTYPE == 28060)) ? 1 : 0
        prop TabName :: " 2802x / 2803x "
        prop NoGen :: 1
        prop Set :: (
            if ($1 != .MODIFYPLLCR3) {    
                .MODIFYPLLCR3 = $1,
                .MODIFYPLLCR = $1
            },
            "ok"
        )
    }
    global MODIFYPLLCR4 :: 1
    {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Initialize PLLCR (2834x)"
        prop JSName :: "MODIFYPLLCR4"
        prop Visible ::  1
        prop Writable :: (GBL.DSPSUBTYPE == 28340) ? 1 : 0
        prop TabName :: " 2834x "
        prop NoGen :: 1
        prop Set :: (
            if ($1 != .MODIFYPLLCR4) {    
                .MODIFYPLLCR4 = $1,
                .MODIFYPLLCR = $1
            },
            "ok"
        )
    }
    global PLLCR2 :: 0x0A
    {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1,2,3,4,5,6,7,8,9,10"
        prop Label :: "PLL Multiplier (PLLCR[DIV]) (282xx/283xx)"
        prop JSName :: "PLLCR2"
        prop Visible :: 1
        prop Writable :: ((GBL.DSPSUBTYPE == 28200) || (GBL.DSPSUBTYPE == 28300)) ? .MODIFYPLLCR2 : 0
        prop TabName :: " 282xx / 283xx "
        prop NoGen :: 1
        prop Set :: (
            .PLLCR = $1,
            .PLLCR2 = $1,
            "ok"
        )
    }
    global PLLCR3 :: 0x0A
    {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: (GBL.DSPSUBTYPE == 28060) ? "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16" : "1,2,3,4,5,6,7,8,9,10,11,12"
        prop Label :: "PLL Multiplier (PLLCR[DIV]) (2802x/2803x/2806x)"
        prop JSName :: "PLLCR3"
        prop Visible :: 1
        prop Writable :: ((GBL.DSPSUBTYPE == 28020) || (GBL.DSPSUBTYPE == 28060)) ? .MODIFYPLLCR3 : 0
        prop TabName :: " 2802x / 2803x "
        prop NoGen :: 1
        prop Set :: (
            .PLLCR = $1,
            .PLLCR3 = $1,
            "ok"
        )
    }
    global PLLCR4 :: 0x0A
    {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        prop Label :: "PLL Multiplier (PLLCR[DIV]) (2834x)"
        prop JSName :: "PLLCR4"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 28340) ? .MODIFYPLLCR4 : 0
        prop TabName :: " 2834x "
        prop NoGen :: 1
        prop Set :: (
            .PLLCR = $1,
            .PLLCR4 = $1,
            "ok"
        )
    }
    global MODIFYPLLCR:: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Initialize PLLCR"
        prop JSName :: "MODIFYPLLCR"
        prop Visible :: 0
        prop Writable :: 1 
        prop NoGen :: 0
        prop Set :: (
            if ($1 != .MODIFYPLLCR) {    
                if (GBL.DSPSUBTYPE == 28000) {
                    .MODIFYPLLCR0 = $1
                }
                else {
                    if (GBL.DSPSUBTYPE == 28100) {
                        .MODIFYPLLCR1 = $1
                    }
                    else {
                        if (GBL.DSPSUBTYPE == 28200 || GBL.DSPSUBTYPE == 28300) {
                            .MODIFYPLLCR2 = $1
                        }
                        else {
                            if (GBL.DSPSUBTYPE == 28020 || GBL.DSPSUBTYPE == 28060) {
                                .MODIFYPLLCR3 = $1
                            }
			    else {
				.MODIFYPLLCR4 = $1
			    }
                        }
                    }
                },
                .MODIFYPLLCR = $1
            },
            "ok"
        )
    }
    global PLLCR :: 0x0A
    {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%01x"
        prop Style :: 0x01 | 0x02
        prop Label :: "PLLCR Register value"
        prop JSName :: "PLLCR"
        prop Visible :: 0
        prop Writable :: .MODIFYPLLCR
        prop NoGen :: 0
        prop Set :: (
            if (GBL.DSPSUBTYPE == 28000) {
                .PLLCR0 = $1
            }
            else {
                if (GBL.DSPSUBTYPE == 28100) {
                    .PLLCR1 = $1
                }
                else {
                    if (GBL.DSPSUBTYPE == 28200 || GBL.DSPSUBTYPE == 28300) {
                        .PLLCR2 = $1
                    }
                    else {
                        if (GBL.DSPSUBTYPE == 28020 || GBL.DSPSUBTYPE == 28060) {
                            .PLLCR3 = $1
                        }
			else {
                            .PLLCR4 = $1
			}
                    }
                }
            },
            .PLLCR = $1,
            "ok"
        )
    }
    global PLLDIV :: 2
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "PLLDIV"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
            if (GBL.DSPSUBTYPE == 28200 || GBL.DSPSUBTYPE == 28300) {
                .PLLDIV2 = $1
            }
            else {
                if (GBL.DSPSUBTYPE == 28020 || GBL.DSPSUBTYPE == 28060) {
                    .PLLDIV3 = $1
                }
                else {
                    if (GBL.DSPSUBTYPE == 28340) {
                        .PLLDIV4 = $1
                    }
		}
	    },	
            .PLLDIV = $1,
            "ok"
        )
    }
    global PLLDIV2 :: 2
    {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "1,2,4"
        prop Label :: "PLL Divider (282xx/283xx)"
        prop JSName :: "PLLDIV2"
        prop Visible :: 1
        prop Writable :: ((GBL.DSPSUBTYPE == 28200) || (GBL.DSPSUBTYPE == 28300)) ? .MODIFYPLLCR2 : 0
        prop TabName :: " 282xx / 283xx "
        prop NoGen :: 1
        prop Set :: (
            .PLLDIV = $1,
	    .PLLDIV2 = $1,
            "ok"
        )
    }
    global PLLDIV3 :: 2
    {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "2,4"
        prop Label :: "PLL Divider (2802x/2803x)"
        prop JSName :: "PLLDIV3"
        prop Visible :: 1
        prop Writable :: ((GBL.DSPSUBTYPE == 28020) || (GBL.DSPSUBTYPE == 28060)) ? .MODIFYPLLCR3 : 0
        prop TabName :: " 2802x / 2803x "
        prop NoGen :: 1
        prop Set :: (
            .PLLDIV = $1,
	    .PLLDIV3 = $1,
            "ok"
        )
    }
    global PLLDIV4 :: 2
    {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "2,4,8"
        prop Label :: "PLL Divider (2834x)"
        prop JSName :: "PLLDIV4"
        prop Visible :: 1
        prop Writable :: (GBL.DSPSUBTYPE == 28340) ? .MODIFYPLLCR4 : 0
        prop TabName :: " 2834x "
        prop NoGen :: 1
        prop Set :: (
            .PLLDIV = $1,
	    .PLLDIV4 = $1,
            "ok"
        )
    }
    global DSPARITHMETIC ::= (
        if (GBL.DSPTYPE == 62 && (GBL.DSPSUBTYPE / 100) == 67) {
            "FLOAT"
        }
        else {
            "FIXED"
        }
    ) {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "FIXED,FLOAT"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPWORDSIZE :: = (
        if (GBL.DSPTYPE == 30 || GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62) {
            32           
        }
        else {
            16           
        }
    ) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Word Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global DSPCHARSIZE :: = (GBL.DSPTYPE == 62 ? 8 :
                             GBL.DSPSUBTYPE == 5599 ? 8 : GBL.DSPWORDSIZE) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "DSP Byte Size"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    global DATAPTRSIZE ::= (
        if (GBL.DSPTYPE == 62) {
            32
        }
        else {
            if (GBL.DSPTYPE == 54) {
                16
            }   
            else {
                if (GBL.DSPTYPE == 55) {
                    if (GBL.MEMORYMODEL == "SMALL") {
                        16      
                    }
                    else {
                        23
                    }
                }
                else {
                        if (GBL.DSPTYPE == 28) {
                                22
                        }
                        else {  
                                0
                        }
                }
            }
        })
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of the Data Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global CODEPTRSIZE ::= (
        if (GBL.DSPTYPE == 62) {
            32
        }
        else {
            if (GBL.DSPTYPE == 54) {
                if (GBL.CALLMODEL == "near") {
                    16
                }
                else {
                    24
                }
            }   
            else {
                if (GBL.DSPTYPE == 55) {
                    24
                }
                else {
                    if (GBL.DSPTYPE == 28) {
                        22
                    }
                    else {
                        0
                    }
                }
            }
        })
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop iComment :: "Size of Code Pointer"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global MEMORYMODEL :: "LARGE"{
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "LARGE"
        prop Label :: "Memory Model"
        prop JSName :: "MEMORYMODEL"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    global AUTOINIT :: "ROM" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "ROM,RAM"
        prop Label :: "C Autoinitialization Model"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global USERINIT :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Call User Init Function"
        prop JSName :: "CALLUSERINITFXN"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
            if ($1 == 0) {       
                .USERINITFXN = @_FXN_F_nop,
                .USERINIT = $1
            }
            else {
                .USERINIT = $1
            },
            "ok"
        )
    }
    global USERINITFXN :: @_FXN_F_nop {
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "User Init Function"
        prop JSName :: "USERINITFXN"
        prop Visible :: 1
        prop Writable :: .USERINIT
        prop NoGen :: 0
    }
    global OLDAUTOCALCULATE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "previous value for autocalculate"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    global ENABLEINST :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Real Time Analysis"
        prop JSName :: "ENABLEINST"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
            if ($1 != .ENABLEINST) {     
                if ($1) {        
                    RTA_toHost.Create("HST"),
        	    RTA_toHost.bufseg = HST.OBJMEMSEG,
                    RTA_fromHost.Create("HST"),
        	    RTA_fromHost.bufseg = HST.OBJMEMSEG,
                    RTA_dispatcher.Create("HST"),
                    IDL_busyObj.Create("IDL"),
                    IDL.USEIDLBUSYOBJ = 1,
                    IDL_cpuLoad.Create("IDL"),
                    IDL.AUTOCALCULATE = .OLDAUTOCALCULATE
                }
                else {
                    RTA_toHost.Delete("HST"),
        	    RTA_toHost.bufseg = MEM_NULL,
                    RTA_fromHost.Delete("HST"),
        	    RTA_fromHost.bufseg = MEM_NULL,
                    RTA_dispatcher.Delete("HST"),
                    IDL_busyObj.Delete("IDL"),
                    IDL.USEIDLBUSYOBJ = 0,
                    IDL_cpuLoad.Delete("IDL"),
                    .OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
                    IDL.AUTOCALCULATE = 0
                },
                .ENABLEINST = $1
            },
            "ok"
        )
    }
    
    global INSTRUMENTED :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Instrumented BIOS library"
        prop JSName :: "INSTRUMENTED"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global CGENERATE :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Do C Generation"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
    global ENABLEDLL :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable Dynamic Loading"
        prop JSName :: "ENABLEDLL"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    global LARGEMODEL ::= .MEMORYMODEL == "LARGE" ? 1 : 
                          .MEMORYMODEL == "HUGE" ? 2 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    
    global SUPPORTCSL :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global ENABLEALLTRC :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable All TRC Trace Event Classes"
        prop JSName :: "ENABLEALLTRC"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
            if ($1) {
                .TRCMASKVALUE = 0xDBEF
            }
            else {
                .TRCMASKVALUE = 0x4000
            },
            .ENABLEALLTRC = $1,
            "ok"
        )
    }
    global TRCMASKVALUE :: 0xDBEF {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    global CALLCSLCFGINIT ::= .DISPCALLCSLCFGINIT {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
    }
    
 
    global CDBPATH :: "" { 
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "CDB search path in COFF file"
        prop JSName :: "CDBRELATIVEPATH"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    prop _cint00Str :: "-u_c_int00 %24t/* link with alternate boot.obj */%0t\n"
    prop _autoInitStr :: ""
    prop _board :: (
        if (HST.RTDX == 1) {
            "lnkrtdx"
        }
        else {
            if (HST.DSM == 1) {
                "lnkdsm"
            }
            else {
                if(HST.EVM54 == 1) {
                    "lnkevm54"
                }
                else {
                    "lnknone"
                }
            }
        }
    )
    prop _dsptype :: GBL.DSPTYPE
    
    prop _instStr :: .INSTRUMENTED ? "" : "_NONINST"
    
    prop _rtsNameStr :: (.RTSLIB)
    prop _biosLibStr :: "-lbios%8S %24t/* DSP/BIOS support */%0t\n"
    prop _compilerModel :: (
    	.MEMORYMODEL == "near" ? "" :
    	((.DSPSUBTYPE == 28300) || (.DSPSUBTYPE == 28340) || (.DSPSUBTYPE == 28060)) ? "fp" : "x"
    )
    prop _librarySuffix :: (
        .MEMORYMODEL == "SMALL" ? ".a28" :
	((.DSPSUBTYPE == 28300) || (.DSPSUBTYPE == 28340) || (.DSPSUBTYPE == 28060)) ? ".a28FP" : ".a28L"
    )
    prop _rtsLibStr :: (
        .SPECIFYRTSLIB ?
        "-l%17S%24t/* C and C++ run-time library support */%0t\n" :
        .MEMORYMODEL == "SMALL" ?
        "-lrts2800.lib%24t/* C and C++ run-time library support */%0t\n" :
	((.DSPSUBTYPE == 28300) || (.DSPSUBTYPE == 28340) || (.DSPSUBTYPE == 28060)) ?
        "-lrts2800_fpu32.lib%24t/* C and C++ run-time library support */%0t\n" :
        "-lrts2800_ml.lib%24t/* C and C++ run-time library support */%0t\n"
    )
    prop _rtdxLibStr :: (
    	RTDX.USERTDX == 0 ? "" : 
    	RTDX.RTDXTYPE == "JTAG" ? "-lrtdx%9S.lib %24t/* RTDX support */%0t\n" :
        "-lrtdxsim%9S.lib %24t/* RTDX support */%0t\n" 
    )
    prop _chipStr :: ""
    prop _pmiLibStr  :: ""
    prop _pmiVoltLibStr  :: ""
    prop _pmiVoltControlLibStr :: ""
    prop _psclLibStr  :: ""
    
    prop _psclCfgLibStr  :: ""
    prop _psclConfigLibStr :: ""
    
    prop _mpcLibStr :: ""
    prop _lnkCmdFile :: MEM.LNKCMDFILE
    prop _lnkCmdStr :: (
        if (MEM.LNKCMDFILE == "") {
            ""
        }
        else {
            "-l%11S %24t/* User Specified Linker cmd file */%0t\n"
        }
    )
    prop _sioLibStr :: SIO.USEISSUERECLAIM == 1 ?
        "-lsioir%8S %24t/* supports SIO Issue/Reclaim model only */%0t\n" :
        "-lsioboth%8S %24t/* supports both SIO models */%0t\n"
    prop _devLibStr :: "-ldrivers%14S %24t/* device drivers support */%0t\n"
    prop _cslLibStr :: ""
    prop _chipType :: .CHIPTYPE
    prop AllocType :: (
        if (.SUPPORTCSL) {
            "1\0,    _cslAllocDesc, _cslmemSeg, _placement"
        }
    )
    prop _cslAllocDesc :: (
        "%8t .csldata: {%12t\n *(.csldata)%8t\n }"
    )
    
 
    prop _cslmemSeg :: MEM.BSSSEG
    prop _placement :: (0x7fffff / 2)
}
 
type MEM {
    isa ObjectMgr
    prop Label :: "MEM - Memory Section Manager"
    prop name :: "MEM"
     
    prop DependsOn :: "SEM"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 115
    prop InstanceIcon :: 116
    prop GlobalHelpTopic :: (
	108
    )
    prop InstanceHelpTopic :: (
	208
    )
    prop InstancePropertyPage :: (
	    "{3D658E70-05E7-11d0-BD44-0020AFEE33C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{3D658E71-05E7-11d0-BD44-0020AFEE33C8}"
    )
    
    prop heapLabelStr :: (.iHeapId)
    prop GenLinkPrologue :: (
	if (GBL.DSPTYPE == 55) {
	    "-stack 0x%1x\n-sysstack 0x%2x\n\nMEMORY {%4t\0, _cmd55stksz, _cmd55systksz"
	}
	else {
	    "-stack 0x%1x\nMEMORY {%4t\0, _stackSize"
	}
    )
    prop _stackSize :: MEM.STACKSIZE
    prop AllocType :: (
	if (.REUSE == 0 && .USERCMD == 0) {
	"20\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_ebssString,	_ebssSeg,	_midPlace, 		_econstString,	_econstSeg,	_midPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}
	else { if (.REUSE == 0 && .USERCMD == 1) {
	"9\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysinitString,	_initSeg,	_sysinitPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}
	else { if (.REUSE == 1 && .USERCMD == 0) {
	 
	"19\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_bssString,	_bssSeg,	_firstPlace, 		_ebssString,	_ebssSeg,	_midPlace, 		_econstString,	_econstSeg,	_midPlace, 		_cinitString,	_cinitSeg,	_midPlace, 		_pinitString,	_pinitSeg,	_midPlace, 		_dataString,	_dataSeg,	_midPlace, 		_constString,	_constSeg,	_midPlace, 		_switchString,	_switchSeg,	_midPlace, 		_cioString,	_cioSeg,	_midPlace, 		_textString,	_textSeg,	_midPlace, 		_frtString,	_frtSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}
	else {  
	"8\0,	_argsString,	_argsSeg,	_midPlace, 		_sysdataString,	_sysdataSeg,	_thirdPlace, 		_trcinitString,	_trcinitSeg,	_midPlace, 		_gblinitString,	_gblinitSeg,	_midPlace, 		_memObjString,	_memObjSeg,	_midPlace, 		_sysregsString,	_regsSeg,	_midPlace, 		_biosString,	_biosSeg,	_midPlace, 		_stackString,	_stackSeg,	_midPlace"
	}}}
    )
 
    prop _firstPlace  :: 0  
    prop _secondPlace :: 0 + 1
    prop _thirdPlace :: 0 + 2
    prop _midPlace    :: (0x7fffff / 2)
    prop _sysinitPlace :: (0x7fffff / 2)
    prop _argsString    :: ("%8t .args: fill=0 {%12t\n *(.args)\n . += 0x%1x;%8t\n }\0, _argsSize")
    prop _bssString     :: ("%8t .bss:     {}")
    prop _ebssString     :: ("%8t .ebss:     {}")
    prop _econstString   :: (
        if (.ENABLELOADSEG == 1) {
            if (MEM.ECONSTSEG == MEM.LOADECONSTSEG) {
                "%8t GROUP {\n %8t .econst: {} \n %8t .printf (COPY): {} \n%8t }"
            }
            else {
		if (MEM.LOADECONSTSEG.space() == "data") {
                    "%8t GROUP {\n %8t .econst: {} load > %1s PAGE 1\n %8t .printf (COPY): {} load > %2s PAGE 1 \n%8t } run\0, _loadeconstSeg, _loadeconstSeg, _pg" 
		}
		else {
                    "%8t GROUP {\n %8t .econst: {} load > %1s PAGE 0\n %8t .printf (COPY): {} load > %2s PAGE 0 \n%8t } run\0, _loadeconstSeg, _loadeconstSeg, _pg" 
		}
            }
        }
        else {
           "%8t GROUP {\n %8t .econst: {} \n %8t .printf (COPY): {} \n%8t }"
        }
    )
    prop _cinitString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.CINITSEG == MEM.LOADCINITSEG) {
		"%8t .cinit:    {}"
	    }
	    else {
		"%8t .cinit:   {} load > %1s%2s, run\0, _loadcinitSeg, _cinitpg"
	    }
	}
	else {
	    "%8t .cinit:    {}"
	}
    )
    prop _pinitString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.PINITSEG == MEM.LOADPINITSEG) {
		"%8t .pinit:   {}"
	    }
	    else {
		"%8t .pinit:   {} load > %1s%2s, run\0, _loadpinitSeg, _pinitpg"
	    }
	}
	else {
		"%8t .pinit:   {}"
	}
    )
prop _trcinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.TRCINITSEG == MEM.LOADTRCINITSEG) {
		"%8t .trcdata:   {}"
	    }
	    else {
		"%8t .trcdata: START(_trcdata_loadstart), END(_trcdata_loadend), SIZE(_trcdata_loadsize), RUN_START(_trcdata_runstart) {\n %8t} load > %1s%2s, run\0, _loadtrcinitSeg, _trcdatapg"
            }
        }
	else {
	    "%8t .trcdata:    {}"
	}
    )
    prop _gblinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.BIOSINITSEG == MEM.LOADBIOSINITSEG) {
		"%8t .gblinit:   {}"
    	    }
	    else {
		"%8t .gblinit:   {} load > %1s%2s, run\0, _loadgblinitSeg, _gblinitpg"
   	    }
	}
	else {
	    "%8t .gblinit:    {}"
	}
    )
    prop _dataString	:: (
	if (.ENABLELOADSEG == 1) {
	  if (MEM.DATASEG == MEM.LOADDATASEG) {
		"%8t .data:    {}"
	  }
	  else{
		if (MEM.LOADDATASEG.space() == "data") {
                    "%8t .data: {} load > %1s PAGE 1, run\0, _loaddataSeg"
                }
                else {
                    "%8t .data: {} load > %1s PAGE 0, run\0, _loaddataSeg"
                }
	  }
 	}
	else {
	    "%8t .data:    {}"
	}
    )
    prop _constString   :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.CONSTSEG == MEM.LOADCONSTSEG) {
               28 == 28 ?
	         "%8t .const:    {}" :
                 "%8t GROUP {\n %8t .const: {} \n %8t .printf (COPY): {} \n%8t }" 
	    }
	    else {
		 if ((28 == 54) || (28 == 28)) {
                     28 == 28 ?
	                "%8t .const:   {} load > %1s PAGE %2s, run\0, _loadconstSeg, _pg" : 
                        "%8t GROUP {\n %8t .const: {} load > %1s PAGE %2s \n %8t .printf (COPY): {} \n%8t } run\0, _loadconstSeg, _pg" 
                 }
                 else {
                     if (28 == 55)
                     {
                        "%8t GROUP {\n %8t .const: {} load > %1s%2s \n %8t .printf (COPY): {} \n%8t } run\0, _loadconstSeg, _constpg" 
                     }
                     else
                     {
                        "%8t GROUP {\n %8t .const: {} load > %1s \n %8t .printf (COPY): {} \n%8t } run\0, _loadconstSeg" 
                     }
                 }
	    }
	}
	else {
               28 == 28 ?
	         "%8t .const:    {}" :
                 "%8t GROUP {\n %8t .const: {} \n %8t .printf (COPY): {} \n%8t }" 
	}
    )
    prop _switchString  :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.SWITCHSEG == MEM.LOADSWITCHSEG) {
		"%8t .switch:   {}"
	    }
	    else {
		"%8t .switch:   {} load > %1s%2s, run\0, _loadswitchSeg, _switchpg"
	    }
	}
	else {
	    "%8t .switch:    {}"
	}
    )
    prop _sysmemString	:: ("%8t .sysmem:  {}")
    prop _cioString	:: ("%8t .cio:     {}")
    prop _memObjString  :: ("%8t .mem: 	  {}")
    prop _sysdataString :: (
	if((GBL.ROM == 0) && (GBL.DSPTYPE == 54)) {
	    "%8t .sysdata: align = 128 {%12t\n GBL_A_SYSPAGE = .;\n GBL_A_SYSDP = GBL_A_SYSPAGE >> 7;\n %8t }"
	}
	else {
	    "%8t .sysdata: {}"
	}
    )
    prop _sysinitString :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.INITSEG == MEM.LOADINITSEG) {
		"%8t .sysinit:   {}"
	    }
	    else {
		"%8t .sysinit:   {} load > %1s%2s, run\0, _loadinitSeg, _sysinitpg"
	    }
        }
	else {
	    "%8t .sysinit:    {}"
	}
    )
    prop _sysregsString :: ("%8t .sysregs: {}")
    prop _textString  :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.TEXTSEG == MEM.LOADTEXTSEG) {
		"%8t .text:    {}"
	    }
	    else {
		"%8t .text:    {} load > %1s%2s, run\0, _loadtextSeg, _textpg"
	    }
        }
	else {
	    "%8t .text:    {}"
	}
    )
    prop _frtString	:: ("%8t frt:    {}")
    prop _biosString    :: (
	if (.ENABLELOADSEG == 1) {
	    if (MEM.BIOSSEG == MEM.LOADBIOSSEG) {
		"%8t .bios:    {}"
	    }
	    else {
		"%8t .bios:    {} load > %1s%2s, run\0, _loadbiosSeg, _biospg"
    	   }
    	}
	else {
	    "%8t .bios:    {}"
	}
    )
    prop _stackString :: (
      if (GBL.DSPTYPE == 62) {
         "%8t .stack: align = 0x8 {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%12t\n _HWI_STKBOTTOM = GBL_stackbeg + 0x%1x - 8;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize, _stackSize"
      }
      else {
	if (GBL.DSPTYPE == 54) {
             "%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = ((GBL_stackbeg + 0x%1x - 1) & 0xfffe) ;%8t\n _HWI_STKBOTTOM = GBL_stackend;%12t\n _HWI_STKTOP = GBL_stackbeg;%8t\n }\0, _stackSize"
        }
        else {
	 if (GBL.DSPTYPE == 55) {
		"%8t GROUP { \n%16t .sysstack :  align = 0x4 {%12t\n %16t GBL_sysstackbeg = .;\n %16t *(.sysstack)\n %16t GBL_sysstackend = GBL_sysstackbeg + 0x%2x -1 ;%12t\n %16t _HWI_SYSSTKTOP = GBL_sysstackbeg; %12t\n %16t_HWI_SYSSTKBOTTOM = (GBL_sysstackend+1);\n%16t} \n%16t .stack: align = 0x4 {%12t\n %16t GBL_stackbeg = .;\n %16t *(.stack)\n GBL_stackend = (GBL_stackbeg + 0x%1x - 1) ;%12t\n %16t _HWI_STKBOTTOM = (GBL_stackend+1);%12t\n %16t _HWI_STKTOP = (GBL_stackbeg);%16t\n }%8t\n } BLOCK(0x20000), run \0, _cmd55stksz, _cmd55systksz"
	}
	  else
	   {  
             "%8t .stack: {%12t\n GBL_stackbeg = .;\n *(.stack)\n GBL_stackend = GBL_stackbeg + 0x%1x - 1;%8t\n _HWI_STKBOTTOM = GBL_stackbeg;%12t\n _HWI_STKTOP = (GBL_stackend + 1);%8t\n }\0, _stackSize"
          }
        }
      }
    )
    prop _memHdrSize :: 8
    prop GenLinkEpilogue :: (
	"%0t}"
    )
    prop _stackSeg :: MEM.STACKSEG
    prop _textSeg :: MEM.TEXTSEG
    prop _frtSeg :: MEM.TEXTSEG
    prop _biosSeg :: MEM.BIOSSEG
    prop _dataSeg :: MEM.DATASEG
    prop _cioSeg :: MEM.CIOSEG
    prop _sysmemSeg :: MEM.SYSMEMSEG
    prop _constSeg :: MEM.CONSTSEG
    prop _initSeg :: MEM.INITSEG
    prop _pinitSeg :: MEM.PINITSEG              
    prop _trcinitSeg :: MEM.TRCINITSEG
    prop _gblinitSeg :: MEM.BIOSINITSEG
    prop _regsSeg :: MEM.SYSDATASEG		 
    prop _sysdataSeg :: MEM.SYSDATASEG
    prop _argsSeg :: MEM.ARGSSEG
    prop _argsSize :: MEM.ARGSSIZE
    prop _bssSeg :: MEM.BSSSEG
    prop _ebssSeg :: MEM.EBSSSEG
    prop _econstSeg :: MEM.ECONSTSEG
    prop _cinitSeg :: MEM.CINITSEG
    prop _memObjSeg :: MEM.CFGOBJSEG
    prop _switchSeg :: MEM.SWITCHSEG
    prop _loadtextSeg :: MEM.LOADTEXTSEG
    prop _loadbiosSeg :: MEM.LOADBIOSSEG
    prop _loadeconstSeg :: MEM.LOADECONSTSEG
    prop _loaddataSeg	:: MEM.LOADDATASEG
    prop _loadconstSeg :: MEM.LOADCONSTSEG
    prop _loadinitSeg :: MEM.LOADINITSEG
    prop _loadpinitSeg :: MEM.LOADPINITSEG      
    prop _loadtrcinitSeg :: MEM.LOADTRCINITSEG
    prop _loadgblinitSeg :: MEM.LOADBIOSINITSEG
    prop _loadcinitSeg :: MEM.LOADCINITSEG
    prop _loadswitchSeg :: MEM.LOADSWITCHSEG
    prop _pg :: MEM.LOADPAGE
    prop _trcdatapg :: (
        if (MEM.LOADTRCINITSEG.space() == "data") { 
            " PAGE 1" 
        }
        else {
            " PAGE 0" 
        }
    )
    prop _biospg :: (
        if (MEM.LOADBIOSSEG.space() == "data") { 
            " PAGE 1" 
        }
        else {
            " PAGE 0" 
        }
    )
    prop _sysinitpg :: (
        if (MEM.LOADINITSEG.space() == "data") { 
            " PAGE 1" 
        }
        else {
            " PAGE 0" 
        }
    )
    prop _gblinitpg :: (
        if (MEM.LOADBIOSINITSEG.space() == "data") { 
            " PAGE 1" 
        }
        else {
            " PAGE 0" 
        }
    )
    prop _textpg :: (
        if (MEM.LOADTEXTSEG.space() == "data") { 
            " PAGE 1" 
        }
        else {
            " PAGE 0" 
        }
    )
    prop _switchpg :: (
        if (MEM.LOADSWITCHSEG.space() == "data") { 
            " PAGE 1" 
        }
        else {
            " PAGE 0" 
        }
    )
    prop _cinitpg :: (
        if (MEM.LOADCINITSEG.space() == "data") { 
            " PAGE 1" 
        }
        else {
            " PAGE 0" 
        }
    )
    prop _pinitpg :: (
        if (MEM.LOADPINITSEG.space() == "data") { 
            " PAGE 1" 
        }
        else {
            " PAGE 0" 
        }
    )
    prop AllocInst :: (
        if (.iAllocHeap == 1) {
        "1\0, _instAllocDesc, _objMemSeg, _placement"
        }
    )
    
 
    prop _instAllocDesc :: (
	.INITSEG.iAllocHeap && .REUSE && .INITSEG == self
	? "%8t GROUP {%12t\n .sysinitgap {. += 0x%2x;}\n .sysinit:\n .%0r$heap: {%16t\n . += 0x%1x;%12t\n }%8t\n } RUN_START(%0r$B), RUN_START(_%0r_base), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length)\0, _heapsize, _sysinitgap, _heaplen"
	: "%8t .%0r$heap: {%12t\n . += 0x%1x;%8t\n } RUN_START(%0r$B), RUN_START(_%0r_base), RUN_SIZE(%0r$L), RUN_SIZE(_%0r_length)\0, _heapsize, _heaplen"
    )
    prop _objMemSeg :: self
    prop _placement :: 0x7fffff - 1
    prop _heapsize :: (.iHeapSize)
    prop _heaplen ::  (.iHeapSize)
    
 
    prop _sysinitgap :: 2 * 1 
    prop GenInstLink :: (GBL.DSPTYPE == 62
	? "%0r %16t: origin = 0x%1x, %40tlen = 0x%2x%4t\0, _origin, _len"
	: GBL.DSPTYPE == 55
	
	? "PAGE %3d: %16t%0r: %26torigin = 0x%1x, %40tlen = 0x%2x%4t\0, _cmd55origin, _cmd55len, _page"
	: "PAGE %3d: %14t%0r: %26torigin = 0x%1x, %50tlen = 0x%2x%4t\0, _origin, _len, _page"
    )
    prop localInit :: (
	$d = "ok",
	scan ($i; MEM) {
	    if ($i.space == "code" && $i.iAllocHeap == 1) {
		$d = .error ("Code memory cannot have a heap")
	    }
	},
	if (.SEGZERO.iAllocHeap == 1) {
	    .SEGZERO.iReqHeapCount++
	}
	else {
	    $d = .error ("Segment for DSP/BIOS objects must be a memory segment with a heap")
	},
	if (.MALLOCSEG.iAllocHeap == 1) {
	    .MALLOCSEG.iReqHeapCount++
	}
	else {
	    $d = .error ("Segment for malloc()/free() must be a memory segment with a heap")
	},
	$d
    )
    prop _page :: (.page)
    prop _origin :: (.base)
    prop _len :: (.len)
    prop maxObjs :: (
	32767				 
    )
    
    prop codeMember :: (
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? (($1.space == "code") || ($1.space == "code/data"))
	    : GBL.DSPTYPE == 54
	        ? ($1.space == "code")
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "code" || ($1.space == "code/data"))
            : GBL.DSPTYPE == 55
	    ? (($1.space == "code") || ($1.space == "code/data"))
	    : ($1.space == "code/data")
    )
    prop dataMember :: (
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 54
	        ? (($1.space != "code") && ($1 != MEM_NULL)) && $1.space != "io"
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 55
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	        : (($1.space == "code/data") && ($1 != MEM_NULL))
    )
    
    prop dataNullMember :: (
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? $1.space == "data" || $1.space == "code/data"
	    : GBL.DSPTYPE == 54
	        ? $1.space != "code" && $1.space != "io"
	    : GBL.DSPTYPE == 28
	        ? $1.space == "data" || $1.space == "code/data"
	    : GBL.DSPTYPE == 55
	    ? $1.space == "data" || $1.space == "code/data"
	    : $1.space == "code/data"
    )
    prop dataCodeMember :: (		 
	$1.dynamicLoading == 1
	    ? 0
	    : GBL.DSPTYPE == 62
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : GBL.DSPTYPE == 54
	        ? $1.space == "code" && $1 != MEM_NULL	 
							 
	    : GBL.DSPTYPE == 28
	        ? ($1.space == "code" || $1.space == "code/data")
		  && $1 != MEM_NULL		 
						 
	    : GBL.DSPTYPE == 55
	    ? ($1.space == "data" || $1.space == "code/data") && $1 != MEM_NULL
	    : $1.space == "code/data" && $1 != MEM_NULL  
							     
    )
    
 
    prop memWritable :: (.iIsModifiable && .iDelUser != "MEM")
    
 
    global CALLBACKOBJ :: nil {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global gNumHeap ::= (
	    $a = 0,
	    scan($i; MEM) {
		if ($i != MEM_NULL) {
		    $a += $i.iAllocHeap
		}
	    },
	    $a
	)  {
	prop NoGen :: 0
    }
    global REUSE ::=
	    (.INITSEG.space != "code" && .INITSEG.iAllocHeap == 1 ? .SAVEREUSE : 0) {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Reuse Startup Code Space"
	prop JSName :: "REUSECODESPACE"
	prop Visible :: 1
	prop Writable  :: .INITSEG.space != "code" && .INITSEG.iAllocHeap == 1
	prop NoGen :: 1
	prop Set :: (
	    .SAVEREUSE = $1,
	    "ok"
	)
    }
    global SAVEREUSE :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
 
    global doCheckOverlap :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
 
    prop validate :: (
        $e = .checkMemOverlap($1),
        if ($e == "ok") {
            $e = .checkHeapSize($1)
        },
        if ($e == "ok") {
            $e = .checkHeapSeg($1)
        },
        $e
    )
    
    
 
    prop checkHeapSeg :: (
        $e = "ok",
        
        if ($1 == MEM_NULL && MEM.NOHEAPS == 0) {
            if (MEM.MALLOCSEG == MEM_NULL) {
                $e = ("Heaps are enabled, but the segment for malloc (MEM.MALLOCSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.MALLOCSEG to it.")
            },
            if (MEM.SEGZERO == MEM_NULL) {
                $e = ("Heaps are enabled, but the segment for DSP/BIOS Objects (MEM.BIOSOBJSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.BIOSOBJSEG to it.")
            }
        },
        $e
    )
    
 
    prop checkHeapSize :: (
        $e = "ok",
        if (MEM.NOHEAPS == 0) {
            if ($1.iAllocHeap && $1 != MEM_NULL) {
                if ($1.iHeapSize > $1.len) {
                    $e = ("MEM segment %s: heap cannot be larger than the length of segment that contains it.")
                }
            }
        },
        $e
    )
    
 
    prop checkMemOverlap :: (
        $e = "ok",
        if ($1 != MEM_NULL && $1.iIsUsed == 1) {
            if ($1.len == 0) {
                $a = $1.base
            }
            else {
                $a = ($1.base + $1.len - 1)
            },
            scan ($j; MEM) {
                if ($1 != $j && $j != MEM_NULL && $j.iIsUsed == 1 &&
                    (GBL.DSPTYPE == 62 ||
                    $1.space == $j.space)) {
                    if (!($j == CACHE_L2 && GBL.L2CONFIGURE == 0)) {
                        $b = $j.base,
                        if ($j.len == 0) {
			    $c = $j.base
			}
			else {
			    $c = ($j.base + $j.len - 1)
			},
                        
 
                        if ($a >= $b && $1.base <= $c) {
                            $e = ("MEM segment %s: overlaps with another segment or cache configuration."),
                            break
                        }
                    }
                }
            }
        },
        $e
    )
     
    global MAPSELECT :: "Map 1" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Map Mode"
	prop JSName :: "MAPMODE"
	prop Enum :: "Map 0,Map 1"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global ARGSSIZE :: 4 {		 
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: 0x01 | 0x02
	prop Label :: "Argument Buffer Size"
	prop JSName :: "ARGSSIZE"
	prop Visible :: 1	 
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1 < 4) {
		.error("The 'arguments' section must have at least 4 words.")
	    }
	    else {
		.ARGSSIZE = $1,
		"ok"
	    }
	)
    }
    global ARGSSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataMember($1)) | (.codeMember($1)) 
	prop Label :: "Argument Buffer Section (.args)"
	prop JSName :: "ARGSSEG"
	prop Visible :: 1	 
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    
    global BIOSSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "BIOS Code Section (.bios)"
	prop JSName :: "BIOSSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
    }
    global STACKSIZE :: GBL.DSPTYPE == 62 ? 1024 : (GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5599) ? 2560 : (GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE != 5599) ? 1024: (GBL.DSPTYPE == 54)?256:(GBL.DSPTYPE == 28) ? 512 : 256 {  
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%04x"
	prop Style :: GBL.DSPTYPE == 54
	    ? 0x01 | 0x02
	    : 0x02
	prop Label :: "Stack Size (MAUs)"
	prop JSName :: "STACKSIZE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
		if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {
		    .STACKSIZE = ($1 & -2)
		}
		else {
		    if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE == 5599)) {
		        .STACKSIZE = ($1  & -4)
		    }
		    else {
		        .STACKSIZE = $1
		    }
		},
		"ok"
	)
	prop PropSetOkUserMsg :: (MEM.STACKSIZE < GlobalStatus.MinStackSize)?"Warning: You are setting the stack size to a value that is less than the Estimated Minimum Stack Size!":"ok"
    }
    global USERCMD :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "User .cmd File For Compiler Sections"
	prop JSName :: "USERCOMMANDFILE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global STACKSEG :: M0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (
			   .dataMember($1) 
			   && (($1.base + $1.len) <= 0x10000)
			   )
	prop Label :: "Stack Section (.stack)"
	prop JSName :: "STACKSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
	prop Set :: (
	    if (GBL.DSPTYPE == 55) {
	        (MEM.STACKSEG = $1), 
		(MEM.SYSSTACKSEG = $1)
		}
		else {
		(MEM.STACKSEG = $1)
		},
		"ok"
	)
    }
    global ENABLELOADSEG :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify Separate Load Addresses"
	prop JSName :: "ENABLELOADADDR"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global LOADBIOSSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Load Address - BIOS Code Section (.bios)"
	prop JSName :: "LOADBIOSSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global INITSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Startup Code Section (.sysinit)"
	prop JSName :: "SYSINITSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
    }
    global LOADINITSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Load Address - Startup Code Section (.sysinit)"
	prop JSName :: "LOADSYSINITSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global BIOSINITSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label ::"DSP/BIOS Init Tables (.gblinit)"
	prop JSName :: "GBLINITSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global TRCINITSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label ::"TRC Initial Value (.trcdata)"
	prop JSName :: "TRCDATASEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global LOADBIOSINITSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label ::"Load Address - DSP/BIOS Init Tables (.gblinit)"
	prop JSName :: "LOADGBLINITSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global LOADTRCINITSEG ::= .TRCINITSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label ::"Load Address - TRC Initial Value (.trcdata)"
	prop JSName :: "LOADTRCDATASEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global SYSDATASEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "DSP/BIOS Kernel State (.sysdata)"
	prop JSName :: "SYSDATASEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global CFGOBJSEG :: L0SARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
        prop Label :: "DSP/BIOS Conf Sections (.*obj)"
	prop JSName :: "OBJSEG"
        prop Visible :: 1
        prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Data"
    }
    global NOHEAPS :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "No Dynamic Memory Heaps"
	prop JSName :: "NOMEMORYHEAPS"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    if ($1) {
		 
		.SEGZERO.iReqHeapCount--,
		.SEGZERO = MEM_NULL,
		.MALLOCSEG.iReqHeapCount--,
		.MALLOCSEG = MEM_NULL,
		TSK.STACKSEG.iReqHeapCount--,
		TSK.STACKSEG = MEM_NULL,
		scan ($i; MEM) {
		    if ($i.iAllocHeap && $i != MEM_NULL) {
			$i.iAllocHeap = 0,
			$i.iHeapSize = 0
		    }
		}
	    },
	    .NOHEAPS = $1,
	    "ok"
	)
	prop PropSetOkUserMsg :: (MEM.NOHEAPS == 1)?"Currently specified heaps no longer valid":"Please reconfigure heaps under individual mem segments"
    }
    global SEGZERO :: L0SARAM { 
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataNullMember($1) && $1.iAllocHeap)
	prop Label :: "Segment For DSP/BIOS Objects"
	prop JSName :: "BIOSOBJSEG"
	prop Visible :: 1
	prop Writable :: MEM.NOHEAPS == 0
	prop NoGen :: 0
        prop Set :: (
            if (.SEGZERO.iReqHeapCount > 0) {
                .SEGZERO.iReqHeapCount--
            },
            .SEGZERO = $1,
            .SEGZERO.iReqHeapCount++,
            "ok"
        )
    }
    global MALLOCSEG :: L0SARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: (.dataNullMember($1) && $1.iAllocHeap)
        prop Label :: "Segment For malloc() / free()"
	prop JSName :: "MALLOCSEG"
        prop Visible :: 1
	prop Writable :: (MEM.NOHEAPS == 0)
	prop NoGen :: 0
        prop Set :: (
            if (.MALLOCSEG.iReqHeapCount > 0) {
                .MALLOCSEG.iReqHeapCount--
            },
            .MALLOCSEG = $1,
            .MALLOCSEG.iReqHeapCount++,
            "ok"
        )
    }
    global LNKCMDFILE :: "" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Specify User Linker cmd File"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    
 
    global TEXTSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Text Section (.text)"
	prop JSName :: "TEXTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADTEXTSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Load Address - Text Section (.text)"
	prop JSName :: "LOADTEXTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global SWITCHSEG :: GBL.DSPTYPE == 62 ? MEM.BSSSEG :(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5561)? H0SARAM: MEM.TEXTSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label :: "Switch Jump Tables (.switch)"
	prop JSName :: "SWITCHSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADSWITCHSEG :: GBL.DSPTYPE == 62 ? MEM.BSSSEG :(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5561)? H0SARAM: MEM.TEXTSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label :: "Load Address - Switch Jump Tables (.switch)"
	prop JSName :: "LOADSWITCHSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global BSSSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "C Variables Section (.bss)"
	prop JSName :: "BSSSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global EBSSSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "C Variables Section (.ebss)"
	prop JSName :: "EBSSSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global CINITSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label :: "Data Initialization Section (.cinit)"
	prop JSName :: "CINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADCINITSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label :: "Load Address - Data Initialization Section (.cinit)"
	prop JSName :: "LOADCINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    
    global PINITSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label :: "C Function Initialization Table (.pinit)"
	prop JSName :: "PINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    
    global LOADPINITSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label :: "Load Address - C Function Initialization Table (.pinit)"
	prop JSName :: "LOADPINITSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global ECONSTSEG :: L0SARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
        prop Label :: "Constant Sections (.econst, .printf)"
        prop JSName :: "ECONSTSEG"
        prop Visible :: 1
        prop Writable :: (.USERCMD == 0)
        prop NoGen :: 1
        prop TabName :: "Compiler Sections"
    }
    global LOADECONSTSEG :: H0SARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
        prop Label :: "Load Address - Constant Sections (.econst, .printf)"
        prop JSName :: "LOADECONSTSEG"
        prop Visible :: 1
        prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
        prop NoGen :: 1
        prop TabName :: "Load Address"
    }
    global CONSTSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Constant Sections (.const, .printf)"
	prop JSName :: "CONSTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADCONSTSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: .dataCodeMember($1) | .dataMember($1)
	prop Label :: "Load Address - Constant Sections (.const, .printf)"
	prop JSName :: "LOADCONSTSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
        prop Set :: (
             .LOADCONSTSEG = $1,
             if ($1.space == "code") {
                 .LOADPAGE = "0"
             }
             else {
                if ($1.space == "data") {
                    .LOADPAGE = "1"
                }
                else {
                    .LOADPAGE = "2"
                }
             },
             "ok"
        )
    }
    
    global LOADPAGE :: "0" { 
        prop Label :: "Page for load address"
        prop JSName :: "LOADPAGE"
	prop Type  :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
	prop NoGen :: 1
        prop Set :: (
             .LOADPAGE = $1,
             "ok"
        )
    }
    global DATASEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Data Section (.data)"
	prop JSName :: "DATASEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global LOADDATASEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.dataCodeMember($1)) | (.dataMember($1))
	prop Label :: "Load Address - Data Section (.data)"
	prop JSName :: "LOADDATASEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0 && .ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global CIOSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Data Section (.cio)"
	prop JSName :: "CIOSEG"
	prop Visible :: 1
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
	prop Set :: (
	    .CIOSEG = $1,
	    .SYSMEMSEG = $1,
	    "ok"
	)
    }
    global SYSMEMSEG ::= L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Data Section (.sysmem)"
	prop JSName :: "SYSMEMSEG"
	prop Visible :: 0
	prop Writable :: (.USERCMD == 0)
	prop NoGen :: 1
	prop TabName :: "Compiler Sections"
    }
    global STUBMEMSEG ::= HWI.STUBMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Function Stub Memory (.hwi)"
	prop JSName :: "HWISEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
	    .STUBMEMSEG = $1,
	    HWI.STUBMEMSEG = $1,
	    "ok"
	)
    }
    
    global LOADSTUBMEMSEG :: HWI.STUBMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Load Address - Function Stub Memory (.hwi)"
	prop JSName :: "LOADHWISEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
     
    global VECMEMSEG ::= HWI.VECMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop Label :: "Interrupt Service Table Memory (.hwi_vec)"
	prop JSName :: "HWIVECSEG"
	prop Visible :: 1
	prop Writable :: 1 
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
		MEM.VECMEMSEG = $1,
		HWI.VECMEMSEG = $1,
		"ok"
	)
    }
    global LOADVECMEMSEG :: HWI.VECMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (MEM.codeMember($1)) | (MEM.dataMember($1))
	prop Label :: "Load Address -Interrupt Service Table Memory (.hwi_vec)"
	prop JSName :: "LOADHWIVECSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    global RTDXTEXTMEMSEG ::= RTDX.TEXTMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "RTDX Text Segment (.rtdx_text)"
	prop JSName :: "RTDXTEXTSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop TabName :: "BIOS Code"
	prop Set :: (
	    .RTDXTEXTMEMSEG = $1,
	    RTDX.TEXTMEMSEG = $1,
	    "ok"
	)
    }
    global LOADRTDXTEXTMEMSEG :: RTDX.TEXTMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (.codeMember($1)) | (.dataMember($1))
	prop Label :: "Load Address - RTDX Text Segment (.rtdx_text)"
	prop JSName :: "LOADRTDXTEXTSEG"
	prop Visible :: 1
	prop Writable :: (.ENABLELOADSEG == 1)
	prop NoGen :: 1
	prop TabName :: "Load Address"
    }
    prop _spaceEnum :: (
	.ENUMSPACE
    )    
    global ENUMSPACE ::=
	GBL.DSPTYPE == 62
	    ? "code,data,code/data,reserved"
	    : GBL.DSPTYPE == 54
	        ? "code,data,io,other,reserved"
		: GBL.DSPTYPE == 28
		   ? "code,code/data,data,io,other,reserved"
                   : GBL.DSPTYPE == 55		 
                      ? "code/data,code,data,io,reserved"
	              : "code/data,io,reserved" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "ENUMSPACE"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst base :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%06x"
	prop Style :: 0x02
	prop Label :: "base"
	prop JSName :: "base"
	prop Visible :: 1
	prop Writable :: (.iIsModifiable)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    $a = .base,
	    .base = $1,
	    if (MEM.CALLBACKOBJ != nil) {
		$e = MEM.CALLBACKOBJ.call(self),
		if ($e != "ok") {
		    .base = $a
		}
	    },
	    $e
	)
    }
    inst len :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
	prop Style :: 0x08
	prop Label :: "len"
	prop JSName :: "len"
	prop Visible :: 1
	prop Writable :: (.memWritable)
	prop NoGen :: 0
	prop Set :: (
	    $e = "ok",
	    $a = .len,
	    .len = $1,
	    if (MEM.CALLBACKOBJ != nil) {
		$e = MEM.CALLBACKOBJ.call(self),
		if ($e != "ok") {
		    .len = $a
		}
	    },
	    "ok"
	)
    }
    inst page ::= (
	
 
	GBL.DSPTYPE == 62
	    ? -1
	    : (GBL.DSPTYPE == 55  || GBL.DSPTYPE == 28)
		? (.space == "code"
		    ? 0
		    : .space == "data"
                        ? 1
                        : .space == "io"
                            ? 2
		            : 0 )        
		:.space == "code"
	   	   ? 0
	   	   : .space == "data"
	               ? 1
	       	       : .space == "io"
	      	           ? 2
		           : 3) {	 
	prop Type  :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
	
    
 
    inst iAllocHeap :: MEM.NOHEAPS == 1 ? 0 : 1 {
	prop Type  :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "create a heap in this memory"
	prop JSName :: "createHeap"
	prop Visible :: 1
	prop Writable :: (.space == "data" || .space == "code/data")
		&& (MEM.NOHEAPS == 0) && .memWritable
	prop NoGen :: 0
	prop Set :: (
	    $a = "ok",
	    if ($1 == 0 && .iReqHeapCount > 0) {
	        .error("This heap is used by one or more of: segment for DSP/BIOS objects, segment for malloc()/free(), TSK default stack segment")
	    }
	    else {
		if ($1 == 0) {
		    .iUserHeapId = 0,
		    .iHeapId = @segment_name
		},
		.iAllocHeap = $1,
		MEM.gDirty = 1,
		$a
	    }
	)
    }
    inst iHeapSize :: 0x00000800/4 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
        prop Style :: 0x02
        prop Label :: "heap size"
	prop JSName :: "heapSize"
        prop Visible :: 1
        prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (MEM.NOHEAPS == 0)
        prop Set :: (
            .iHeapSize =  $1,
            "ok"
        )
        prop NoGen :: 1
    }
    inst iSegZero ::= MEM.SEGZERO
    inst iUserHeapId :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "enter a user defined heap identifier label"
	prop JSName :: "enableHeapLabel"
	prop Set :: (
	    if ($1 == 0) {
		.iHeapId = @segment_name
	    },
	    .iUserHeapId = $1,
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (.NOHEAPS == 0)
	prop NoGen :: 1
    }
    inst iHeapId :: @segment_name {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "heap identifier label"
	prop JSName :: "heapLabel"
	prop Set :: (
	    $e = .checkHeapId($1),
	    if ($e == "ok") {
		.iHeapId = $1
	    },
	    $e
	)
	prop Writable :: (.iAllocHeap) && (.iIsModifiable) && (.NOHEAPS == 0) &&(.iUserHeapId)
	prop Visible :: 1
	prop NoGen :: 0
    }
    prop checkHeapId :: (
	$e = "ok",
	scan ($i; MEM) {
	    if ($i.iAllocHeap == 1 && $i.iUserHeapId == 1 && $i.iHeapId == $1 && $i.iHeapId != @segment_name) {
		$e = .error ("This identifier label is already in use"),
		break
	    }
	},
	$e
    ) 
    inst iReqHeapCount :: 0 {	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst space :: ( GBL.DSPTYPE == 55 ? "code/data" : "data") {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	
 
	prop Enum :: MEM._spaceEnum()
	prop JSName :: "space"
	prop Visible :: 1
	prop Writable :: (.memWritable)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if ($1 != "data" && $1 != "code/data" && .iAllocHeap == 1) {
		$e =.error("Cannot select this space if a heap will be created")
	    }
	    else {
		$a = .space,
		.space = $1,
		if (MEM.CALLBACKOBJ != nil) {
		    $e = MEM.CALLBACKOBJ.call(self),
		    if ($e != "ok") {
			.space = $a
		    }
		}
	    },
	    $e
	)
    }
    inst dynamicLoading :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Reserved for dynamic loading"
	prop JSName :: "dynamicLoading"
	prop Visible :: GBL.ENABLEDLL
	prop Writable :: GBL.ENABLEDLL
	prop NoGen :: 1
    }
    inst iIsModifiable :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
}
object MEM_NULL :: MEM {
    param iComment :: "Place holder segment which allows user to disable heaps"
    param iAllocHeap :: 1
    param iIsUsed :: 0
}
 
type OBJ {
    isa ObjectMgr
    prop name :: "OBJ"
    prop Visible :: 0
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _objMemDesc, _memSeg, _placement"
	}
    )
    prop _objMemDesc :: ("%8t .obj: {}")
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffff / 2)
}
 
type BUF {
    isa  ObjectMgr
    prop name :: "BUF"
    prop Label :: "BUF - Buffer Manager"
    prop IsContainedIn :: SYSTEM 
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop InstanceHelpTopic :: (
	421
    )
    
    prop GlobalHelpTopic :: (
	321
    )
    prop InstancePropertyPage :: (
	"{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop maxObjs :: (32767)
    
     
    prop AllocType :: (
      if (.gNumOf > 0) {
	"1\0,      _globalAllocDesc, _memSeg, _placement"
      }
    )
    prop _globalAllocDesc :: (
       "%8t.buf:{}"
    )
	    
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
     
    prop AllocInst :: (
          "1\0, _instAllocDesc, _instMemSeg, _placement"
    )
    prop _instAllocDesc :: (
          "%8t .%0s$data: align = 0x%1x {%12t\n %0s$databeg = .;\n .+= %2d; %8t\n }\0, _objAlign, _buflength"
    )
    prop _objAlign :: .align
    prop _instMemSeg :: .bufseg
    prop _buflength :: (.postalignsize *  .bufcount) 
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "buf.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far BUF_Obj %0r;\n\0"
	}
	else {
	    "extern BUF_Obj %0r;\n\0"
	}
    )
    
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = ((7 + 3) * 1)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = ((7 + 4) * 1)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = ((7 + 3) * 1)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (12 + 6)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (12 + 6)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (7 + 4)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (12 + 6)
        },
        $a
    )
     
    prop dataSize :: (
	$d = 0,
	scan ($i; BUF) {
	    if ($i.IsConfObj()) {
		$d += $i.len 
	    },
	    $d += BUF.objectSize	
	},
	$d
    )
     
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ENABLED :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Compile in logging"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     
    inst bufseg :: .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Memory segment for buffer pool"
	prop JSName :: "bufSeg"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
     
    inst bufcount :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer count"
	prop JSName :: "bufCount"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    .bufcount = $1,
            .postalignsize = (.size + (.align - 1)) & ~(.align - 1),
	    .len = $1 * .postalignsize, 
	    "ok"
	)
    }
     
    inst size :: 4  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer size (MADUs)"
	prop JSName :: "size"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
             if($1 < 4) { 
                .error("Size should be atleast 4 words")
             }
             else { 
	        .size = $1,
                .postalignsize = ($1 + (.align - 1)) & ~(.align - 1),
                .len = .postalignsize * .bufcount,
	        "ok"
             }
	)
    }
     
     inst align :: 2 { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Buffer alignment(Power of 2)"
	prop JSName :: "align"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0 
	prop Set :: (
             if($1 < 2) { 
                .error("Alignment should be atleast 2 ")
             }
             else { 
	         .align = $1,
                 .postalignsize = (.size + ($1 - 1)) & ~($1 - 1),
                 .len = .postalignsize * .bufcount,
	         "ok"
             }
	 )
    }
     
    inst len :: .size {
	prop Label :: "Buffer pool length (MADUs)"
	prop JSName :: "len"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
     
    inst postalignsize :: .size {
	prop Label :: "Buffer size after alignment (MADUs)"
	prop JSName :: "postalignsize"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    
}
 
type POOL {
    isa Module
    prop Visible :: 1
    prop name :: "POOL"
    prop Label :: "POOL - Allocator Manager"
    prop IsConfMod :: .USEPOOL 
    prop IsContainedIn :: SYSTEM
 
    prop GlobalIcon :: 199
    prop InstanceIcon :: 200
    prop GlobalHelpTopic :: (
	324
    )
    prop InstanceHelpTopic :: (
	424
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop DependsOn :: "MEM,BUF"
    global USEPOOL :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Allocator Manager"
	prop JSName :: "ENABLEPOOL"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
 
 
 
 
type CLK {
    isa ObjectMgr
    prop name :: "CLK"
    prop Label :: "CLK - Clock Manager"
    prop IsContainedIn :: SCH
    prop IsConfMod :: 1 		 
    prop GlobalIcon :: 103
    prop InstanceIcon :: 104
    prop InstanceHelpTopic :: (
	202
    )
    prop GlobalHelpTopic :: (
	102
    )
    prop InstancePropertyPage :: (
	"{EEB2AB41-51E3-11d0-A61D-0000C070F3E9}"
    )
    prop GlobalPropertyPage :: (
	"{EEB2AB40-51E3-11d0-A61D-0000C070F3E9}"
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {
	     $a = (2 * 1)
	}
	else {
	     $a = (1 * 1)
	},
	$a
    )
    prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.%1L: {\n%8t CLK_F_gethtime = %5s;\n %4S \n%4t} > %3s %6s, RUN_START(%1U_A_TABBEG) \0, name, _objSize, _memSeg, _linkString, clkFxn, pageString"
    )
    prop GenLinkEpilogue :: (
	"%0t}\n_CLK_PRD = CLK_PRD;\n_CLK_COUNTSPMS = CLK_COUNTSPMS;\n_CLK_REGS = CLK_REGS;\n_CLK_USETIMER = CLK_USETIMER;\n_CLK_TIMERNUM = CLK_TIMERNUM;\n_CLK_TCR = CLK_TCR;\n_CLK_TDDR = CLK_TDDR;\n\0"
    )
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no CLK objs */"
    prop _memSeg :: CLK.OBJMEMSEG
     
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop pageString :: (
                       CLK.OBJMEMSEG.space() == "code"
                         ? " PAGE 0"
                         : CLK.OBJMEMSEG.space() == "data"
                           ? " PAGE 1"
                           : CLK.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
    )
    prop clkFxn :: (.USETIMER == 1) ? .CLKFXN : @FXN_F_zero
    
    prop maxObjs :: (
	32767				 
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    prop localInit :: (
	if (GBL.CALLBACKOBJ != CLK) {
	    CLK.gGBLChain = GBL.CALLBACKOBJ,
	    GBL.CALLBACKOBJ = CLK
	}
    )
    
    prop dataSize :: (
	.objectSize() * (CLK.gNumOf + 1)	 
    )
    prop localCanCreate :: (
	.USETIMER ? "ok" : .error ("The CLK Manager must be enabled before inserting a CLK")
    )
    global gGBLChain :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
 	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
    global REGS :: 0x00000c10 {	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
    }
    global TIMERNUM ::  0
	{	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop NoGen :: 0
    }
    global FREERUN ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Continue to run on sw breakpoint (free run)"
	prop JSName :: "FREERUN"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 0
	prop Set :: (
	    if (CLK.USETIMER) {
		CLK.FREERUN = $1,
		"ok"
	    }
	    else {
		.error("CLK Manager must be enabled in order to do the setting.")
	    }
	)
    }
    global USETIMER :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable CLK Manager"
 	prop JSName :: "ENABLECLK"
	prop Visible :: 1
	prop Writable :: .gNumOf > 0 ? 0 : 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 == 1 && .USETIMER == 0) {
                if (HWI_TINT.client == "CSL") {
                   .error("Timer0 Interrupt already in use by CSL")
                }
                else {
		    if (HWI_TINT.client == "USER" && HWI_TINT.function != @HWI_unused) {
		        .error("HWI Timer interrupt already in use.")
		    }
		    else {
		        HWI_TINT.function = @CLK_F_isr,
		        HWI_TINT.client = "CLK",
		        HWI.gDirty = 1,
		        .USETIMER = 1,
		        CLK.TIMEFXN = CLK.HIRES ? CLK.clkFxn() : @CLK_F_getltime,
		        GlobalStatus.gDirty = 1,
		        if (GlobalStatus.MinStackSize > MEM.STACKSIZE) {
		            CLK.TIMEFXN = @FXN_F_zero,
		            HWI_TINT.function = @HWI_unused,
		            HWI_TINT.client = "USER",
		            HWI.gDirty = 1,
         	            .USETIMER = 0,
		            GlobalStatus.gDirty = 1,
		            .error("Current stack size inadequate to enable CLK")
		         }
		         else {
		      
		             if (GBL.ENABLEINST == 1) {
                                 IDL_busyObj.Create("IDL"),
		                 IDL.USEIDLBUSYOBJ = 1,
		                 IDL_cpuLoad.Create("IDL"),
		                 IDL.AUTOCALCULATE = GBL.OLDAUTOCALCULATE
		             },
		             "ok"
		         }
		    }
                }
	    }
	    else {
		if ($1 == 0 && .USETIMER == 1) {
		    if (.gNumOf == 0) {
			CLK.TIMEFXN = @FXN_F_zero,
			HWI_TINT.function = @HWI_unused,
			HWI_TINT.client = "USER",
			HWI.gDirty = 1,
			.USETIMER = 0,
		        if (GBL.ENABLEINST == 1) {
		            IDL_busyObj.Delete("IDL"),
			    IDL.USEIDLBUSYOBJ = 0,
		            IDL_cpuLoad.Delete("IDL"),
                            GBL.OLDAUTOCALCULATE = IDL.AUTOCALCULATE,
                            IDL.AUTOCALCULATE = 0
			},
		          "ok"
		    }
		    else {
			.error("CLK cannot be disabled until all its objects are deleted.")
		    }
		}
		else {
		    "ok"
		}
	    }
	)
    }
    
    global HIRES ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use high resolution time for internal timings"
 	prop JSName :: "HIRESTIME"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
	prop Set :: (
	    if (CLK.USETIMER) {
		CLK.HIRES = $1,
		if (CLK.USETIMER) {
		        CLK.TIMEFXN = CLK.HIRES ? CLK.clkFxn() : @CLK_F_getltime
		},
		"ok"
	    }
	    else {
		.error("CLK Manager must be enabled in order to get high resolution timings.")
	    }
	)
    }
    global INSTRPERCLK :: 1 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
     
    global MICROSECONDS :: (((float((CLK . PRD)) + CLK . adjustPrd) * ((CLK . TDDR) + 1.0) * 1 / GBL . MIPS)) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.4f"
	prop Label :: "Microseconds/Int"
 	prop JSName :: "MICROSECONDS"
	prop Set :: (
	    .setMicroseconds($1)
	)
	prop Visible :: 1
	prop Writable :: ((CLK.PROGTIMREGS != 0) | (.USETIMER == 0)) ? 0 : 1
	prop NoGen :: 1
    }
    global MICROSECS ::= int(round(.MICROSECONDS)) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style ::  0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global PROGTIMREGS ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Directly configure on-chip timer registers"
	prop JSName :: "CONFIGURETIMER"
	prop Visible :: 1
	prop Writable :: .USETIMER
	prop NoGen :: 1
    }
    global TCR :: = 0x20 | CLK.TDDR {	 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global FIXTDDR :: (GBL.DSPTYPE == 62) ? 1 : 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Fix TDDR"
 	prop JSName :: "FIXTDDR"
	prop Visible :: (GBL.DSPTYPE != 62) && (GBL.DSPSUBTYPE != 2420) && 
			(GBL.DSPSUBTYPE != 5599)
	prop Writable :: CLK.PROGTIMREGS && (GBL.DSPTYPE != 62) &&
	    (GBL.DSPSUBTYPE != 2420) && (GBL.DSPSUBTYPE != 5599)
	prop NoGen :: 1
    }
    
    
 
    global TDDR :: (GBL.DSPTYPE == 62) ? 0 : 
		   (GBL.DSPSUBTYPE == 5502) ? 0 :
		   (GBL.DSPSUBTYPE == 5599) ? 0 :
		   (GBL.DSPSUBTYPE == 5802) ? 0 :
		   (int(round(1000.0 * GBL.MIPS/1)) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
	prop Label :: GBL.DSPSUBTYPE == 5561 ? "TDDR Register (PREMD=0)" : 
						"TDDR Register"
 	prop JSName :: "TCRTDDR"
	prop Set :: (
	    if ((GBL.DSPSUBTYPE != 5502)  && (GBL.DSPSUBTYPE != 5802)
		&& (GBL.DSPTYPE != 62) && (GBL.DSPSUBTYPE != 5599)
		&& ($1 > 0xffff)) {
	        .error("The on-chip timer does not have enough range to support this value, maximum is 15.")
	    }
	    else {
		CLK.TDDR = $1,
		CLK.MICROSECONDS = ((float((CLK . PRD)) + CLK . adjustPrd) * ((CLK . TDDR) + 1.0) * 1 / GBL . MIPS),
		if (CLK.CALLBACKOBJ != nil) {
		    CLK.CALLBACKOBJ.call()
		},
		"ok"
	    }
	)
	prop Visible :: GBL.DSPTYPE != 62
	prop Writable :: CLK.PROGTIMREGS && GBL.DSPTYPE != 62
	prop NoGen :: 0  
    }
    
 
    global TDDRHIGH ::= ((.TDDR & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    global PRD :: int(round((1000.0 * GBL.MIPS / (CLK.TDDR + 1) / 1) - CLK.adjustPrd))  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
	prop Label :: (GBL.CLKTYPE == 700)? "Compare0 Register" : "PRD Register"
 	prop JSName :: "PRD"
	prop Set :: (
	    
 
	    CLK.PRD = $1,
	    CLK.MICROSECONDS = ((float((CLK . PRD)) + CLK . adjustPrd) * ((CLK . TDDR) + 1.0) * 1 / GBL . MIPS),
	    if (CLK.CALLBACKOBJ != nil) {
		CLK.CALLBACKOBJ.call()
	    },
	    "ok"
	)
	prop Visible :: 1
	prop Writable :: ((.PROGTIMREGS) && (.USETIMER)) ? 1 : 0
	prop NoGen :: 0
    }
    
    
 
    global PRDHIGH ::= ((.PRD & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    
 
    global COUNTSPMS ::= int(round(GBL.MIPS * 1000.0 / (CLK.TDDR + 1) / 1)) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
    }
    
    
 
    global COUNTSPMSHIGH ::= ((.COUNTSPMS & 0xffff0000) >> 16) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    prop adjustPrd :: 	(GBL.DSPTYPE == 62 ? 0 : 
	    		GBL.DSPSUBTYPE == 5599 ? 0 : 1)
    
      	 
    prop seizeHwi :: (
      if ($1.client == "USER" && $1 == HWI_UNUSED) {
	  .error("Interrupt not mapped for selected timer.")
      }
      else {
	if ($1.client == "USER" && $1.function != @HWI_unused) {
	    .error("Interrupt mapped to selected timer is already in use.")
	}
	else {
	    if( $1.client == "CSL") {
	    .error("Interrupt mapped to selected timer is already in use by CSL.")
	    }
	    else {
	    	$1.function = @CLK_F_isr,
	    	$1.client = "CLK",
	    	HWI.gDirty = 1,
	    	"ok"
	    }
	}
      }
    )
    prop releaseHwi :: (
	$1.function = @HWI_unused,
	$1.client = "USER",
	HWI.gDirty = 1,
	"ok"
    )
    prop seizeTimer :: (
        if( $1 == "Timer 0") {
            .WHICHTIMER = "Timer 0",
            .WHICHHWI = Timer_0.iHwi,
            .REGS = (GBL.DSPSUBTYPE == 5599)? 0x620 : 0x01000,
            .TIMERNUM = 0,
            .TIMERIMR = 0x0,
            .TIMERIFR = 0x1,
            .INTBIT = 4,
            .TIMERIMRMASK = .WHICHHWI.Ier0Mask,
            .IMR0TINTMASK = .WHICHHWI.Ier0Mask,
            .IMR1TINTMASK = 0x0,
            .setMicroseconds(.MICROSECONDS)
        }
        else {
          if ($1 == "Timer 1") {
            .WHICHTIMER = "Timer 1",
            .WHICHHWI = Timer_1.iHwi,
            .REGS = (GBL.DSPSUBTYPE == 5599)? 0x640 : 0x2400,
            .TIMERNUM = 1,
            .TIMERIMR = 0x45,
            .TIMERIFR = 0x46,
            .INTBIT = 6,
            .TIMERIMRMASK = .WHICHHWI.Ier1Mask,
            .IMR0TINTMASK =  0x0,
            .IMR1TINTMASK =  .WHICHHWI.Ier1Mask,
            .setMicroseconds(.MICROSECONDS)
          } 
          else {
            if ($1 == "Timer 2") {
              .WHICHTIMER = "Timer 2",
              .WHICHHWI = Timer_2.iHwi,
              .REGS = 0x4000,
              .TIMERNUM = 2,
              .TIMERIMR = 0x0,
              .TIMERIFR = 0x1,
              .INTBIT = 11,
              .TIMERIMRMASK = .WHICHHWI.Ier0Mask,
              .IMR0TINTMASK = .WHICHHWI.Ier0Mask,
              .IMR1TINTMASK =  0x0,
              .setMicroseconds(.MICROSECONDS)
            } 
          }
        },
            "ok"
    )
 
    prop setMicroseconds :: (
	
 
	
 
	$a = FIXTDDR == 1 ? .TDDR : 0xffff,
	$b = 0xffff,
	$c = (float($a) + 1.0) * ((float($b) + .adjustPrd) /
	    (GBL.MIPS / 1)),
	if ($1 < $c && $1 > 0.1) {
	    if (.FIXTDDR == 0) {
		.TDDR = int((1.0 * $1 * GBL.MIPS / 1) /
		    (float($b) + .adjustPrd))
	    },
	    .PRD = int((1.0 * $1 * GBL.MIPS) /
		(1 * (.TDDR + 1.0))) - .adjustPrd,
	    .MICROSECONDS = ((float((. PRD)) + CLK . adjustPrd) * ((. TDDR) + 1.0) * 1 / GBL . MIPS),
	    if (.CALLBACKOBJ != nil) {
		.CALLBACKOBJ.call()
	    },
	    "ok"
	}
	else {
	    .error("The on-chip timer does not have enough range to support this combination of DSP MIPS and Microseconds/Int")
	}
    )
    
 
    prop call :: (
	$a = ((float((CLK . PRD)) + CLK . adjustPrd) * ((CLK . TDDR) + 1.0) * 1 / GBL . MIPS),
	$b = CLK.MICROSECONDS,
	$e = "ok",
	if (($e = .setMicroseconds(CLK.MICROSECONDS)) == "ok") {
	    if (CLK.gGBLChain != nil) {
		$e = CLK.gGBLChain.call()
	    },
	    if ($e != "ok") {
		.setMicroseconds($b),
		.error($e)
	    }
	    else {
		"ok"
	    }
	}
	else {
	    $e
	}
    )
    global INSTRUCTIONS ::= (
	1.0 * (float(CLK.PRD) + CLK.adjustPrd) * (CLK.TDDR + 1.0) * 1
    ) {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.0f"
	prop Label :: "Instructions/Int"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
    
 
    global TIMEFXN ::= CLK.clkFxn() {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
 
    
 
    global HOOKFXN ::= (.gNumOf > 0 ? @CLK_F_run : @CLK_F_rete) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
    global CLKFXN ::= (CLK.PRD == 0xffff) ? 
		      @CLK_F_getfhtime : @CLK_F_getshtime {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global CALDIV ::= GBL.DSPSUBTYPE == 2420? .HTIMEDIV : 1 
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global CALMULT ::= GBL.DSPSUBTYPE == 2420? .HTIMEMULT 
		       : GBL.DSPSUBTYPE == 1510 ? .PRDMULTFACTOR * 1
		       : 1
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEDIV ::=  GBL.DSPSUBTYPE == 2420 ? .setHtimeParams() : 1
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEMULT ::= GBL.DSPSUBTYPE == 1510 ? .PRDMULTFACTOR * 1
		         : GBL.DSPSUBTYPE == 2420 ?.setHtimeParams() 
			 : GBL.DSPSUBTYPE == 5502 ? 1 
		         : GBL.DSPSUBTYPE == 6499 ? 1
			 : ((.TDDR + 1) * 1) 
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEDIV ::=  GBL.DSPSUBTYPE == 2420 ? 
    			 .INPUTCLK  == 0.032 ? .setLtimeParams() : .HTIMEDIV
			 : 1
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global LTIMEMULT ::=
        GBL.DSPSUBTYPE == 1510 ? (.PRDMULTFACTOR * .PRD * 1)
    	: GBL.DSPSUBTYPE == 2420 ?  .INPUTCLK == 0.032 ?.setLtimeParams() 
	: (.HTIMEMULT * .PRD) 
	: ((.TDDR + 1) * (.PRD + .adjustPrd) * (1))	
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global HTIMEPERLTIME ::= 
        GBL.DSPSUBTYPE == 5502 ? int(round(GBL.MIPS * .MICROSECONDS/1)) 
        : GBL.DSPSUBTYPE == 2420 ? int(round(.HTIMECLK * .MICROSECONDS/1))
        : GBL.DSPSUBTYPE == 6499 ? int(round(GBL.MIPS * .MICROSECONDS))
	: (.PRD + CLK.adjustPrd)
    {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x20
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst function :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "function"
 	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
 
type PRD {
    isa ObjectMgr
    prop name :: "PRD"
    prop Label :: "PRD - Periodic Function Manager"
    prop IsContainedIn :: SCH
    
    prop IsConfMod :: 1
    prop GlobalIcon :: 119
    prop InstanceIcon :: 120
    prop InstanceHelpTopic :: (
	210
    )
    
    prop GlobalHelpTopic :: (
	110
    )
    prop InstancePropertyPage :: (
	"{B7240DE0-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE1-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
 
    prop STSGetMaxFmt :: (
	"%g ticks"
    )
    prop STSGetSumFmt :: (
	PRD.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	"%.2f ticks"
    )
    prop GetPeriod :: .period
    prop IsOneShot :: .mode == "one-shot" ? 1 : 0
    prop objectSize :: (
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (10 * 1)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
	    $a = (9 * 1)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (12 * 1)
	},
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (12 * 1)
	},
	if (GBL.DSPTYPE == 62) {
	    $a = (8 * 1)
	},
	$a
    )
    prop GenLinkPrologue :: (
        "SECTIONS {%4t\n.prd: RUN_START(PRD_A_TABBEG), RUN_END(PRD_A_TABEND) {%4t\n} > %1s%2s\0, memSeg, pageString"
    )
    
    prop GenLinkEpilogue :: (
        "%0t}\nPRD_A_TABLEN = %1d;\n\0, numInst"
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62
                      ? ""
                      : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
                      ? (
                          PRD.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : PRD.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : PRD.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )
                      : " PAGE 1"
    prop memSeg :: PRD.OBJMEMSEG
    prop objSize :: GBL.DSPTYPE == 55 ? .objectSize() * 2 : .objectSize()
    prop numInst :: (
    	PRD.gNumOf
    )
    prop dataSize :: (
	.objectSize() * PRD.gNumOf
    )
    prop localInit :: (
	if (CLK.CALLBACKOBJ != nil) {
	    .error("PRD initialization failure")
	},
	CLK.CALLBACKOBJ = PRD,
	if (PRD.USECLK && PRD_clock.iIsUsed == 0) {
	    PRD_clock.Create("PRD")
	},
	if (PRD_clock.iIsUsed == 1) {
	  if (.gNumOf == 0) {
            if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {
  	      PRD_clock.function = @PRD_F_tick
            }
            else {
  	      PRD_clock.function = @FXN_F_nop
            }
          }
          else {
  	    PRD_clock.function = @PRD_F_tick
          }
        }
    )
    prop localCanCreate :: (
	if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
	  .error(" System Stack Size too small")
	  }
        else {
	.myCreate("can")
	}
    )
    
    prop localCreate :: (
	STS.gNumEmbed += 1,
	if (($a = .myCreate("do")) == "ok") {
	  if (PRD_clock.iIsUsed == 1) {
	    if (.gNumOf == 0) {
  	      PRD_clock.function = @PRD_F_tick
            }
          }
        },
        $a
    )
    
    prop localCanDelete :: (
	.myDelete("can")
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	if (($a = .myDelete("do")) == "ok") {
	  if (.gNumOf == 1) {
	    if (PRD_clock.iIsUsed == 1) {
              if (TSK.USETSK == 1 && TSK.TSKTICK == "PRD") {
  	        PRD_clock.function = @PRD_F_tick
              }
              else {
  	        PRD_clock.function = @FXN_F_nop
              }
            }
	  }
	},
        $a
    )
    
    prop maxObjs :: (
	32767				 
    )
    prop myCreate :: (
	if (PRD_swi.function != @PRD_F_swi) {
	    PRD_swi.function = @PRD_F_swi
	},
	if (PRD_swi.iIsUsed) {
	    "ok"
	}
	else {
	    if (SWI.CanCreate() == "ok") {
		if ($1 == "do") {
		    if (KNL_swi.iIsUsed == 1 && PRD_swi.pri == 0) {
			PRD_swi.pri = 1
		    },
		    PRD_swi.Create("PRD")
		}
		else {
		    "ok"
		}
	    }
	    else {
		.error("Can't create an SWI for PRD (try deleting a SWI)")
	    }
	}
    )
    
    prop myDelete :: (
	if (PRD_swi.function != @PRD_F_swi) {
	    PRD_swi.function = @PRD_F_swi
	},
	if (.gNumOf == 1) {
	    if ($1 == "do") {
		PRD_swi.Delete("PRD")
	    }
	    else {
		"ok"
	    }
	}
	else {
	    "ok"
	}
    )
    
 
    prop call :: (
	if (CLK.USETIMER != 0) {
	    PRD.MICROSECONDS = CLK.MICROSECONDS
	},
	PRD.CALLBACKOBJ.call()
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "prd.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far PRD_Obj %0r;\n\0"
	}
	else {
	    "extern PRD_Obj %0r;\n\0"
	}
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USECLK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use CLK Manager to drive PRD"
	prop JSName :: "USECLK"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1 == 1 && .USECLK == 0) {
		if (CLK.USETIMER == 0) {
		    .error("In order to drive periodic functions, the CLK Manager must be enabled")
		}
		else {
		    .USECLK = 1,
		    .MICROSECONDS = CLK.MICROSECONDS,
		    CLK.CALLBACKOBJ = PRD,
		    PRD_clock.Create("PRD"),
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE){
                      .USECLK = 0,
		      .MICROSECONDS = 0.0,
                      CLK.CALLBACKOBJ = nil,
                      PRD_clock.Delete("PRD"),
                      .error("Current Stack size inadequate to enable this option")
		      }
		    else {
		      "ok"
		    }
		}
	    }
	    else {
		if ($1 == 0 && .USECLK == 1) {
		    .USECLK = 0,
		    .MICROSECONDS = 0.0,
		    CLK.CALLBACKOBJ = nil,
		    PRD_clock.Delete("PRD")
		},
		      "ok"
	    }
	)
	prop NoGen :: 1
    }
   
    
     
    global MICROSECONDS ::= CLK.MICROSECONDS {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.1f"
	prop Label :: "Microseconds/Tick"
	prop JSName :: "MICROSECONDS"
	prop Visible :: 1
	prop Writable :: .USECLK == 0
	prop NoGen :: 1
    }
    global SCALAR ::= (		 
	$d = 2,
	$f = 0,
	
 
	while ($d <= 0x4000 && $f == 0) {
	    scan ($i; PRD) {
		if ((($i.period / $d) * $d != $i.period)) ||
		    ($i.mode == "one-shot") {
		    $f = 1
		}
	    },
	    if ($f == 0) {
		$d = 2 * $d
	    }
	},
	$d / 2
    ) {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     
    prop DEFAULT_THOOKFXN :: @KNL_tick_stub 
    global THOOKFXN :: .DEFAULT_THOOKFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "System Tick Hook Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst period :: 0x7fff {	 
	prop Label :: "period (ticks)"
	prop JSName :: "period"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if (($1 > 0) && ($1 < 0x8000)) {
		.period = $1,
		.gDirty = 1,
		"ok"
	    }
	    else {
		.error("Periodic function periods must be greater than 0 and less than 0x8000")
	    }
	)
    }
    inst mode :: "continuous" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "continuous,one-shot"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst function :: @FXN_F_nop {	 
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst milliseconds ::= (
	(.period * PRD.MICROSECONDS) / 1000.0
    ) {
	prop Label :: "period (ms)"
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style :: 0x04
	prop Format :: "%.1f"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 1
    }
     
    inst Order :: 0 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
        prop NoGen :: 0
        prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
    
 
    inst filter :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    inst maxformat :: "%g ticks" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: "%g ticks" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: "%.2f ticks" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    
 
    inst unittype :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "unittype"
	prop NoGen :: 0
    }
}
 
object PRD_swi :: SWI {
    param function :: @PRD_F_swi
    param iComment :: "This Software ISR executes all configured PRD functions"
    param iDelUser :: "PRD"
    param iDelMsg  :: (
	"This object is automatically deleted when all PRD objects are deleted"
    )
}
 
object PRD_clock :: CLK {
    param function :: @PRD_F_tick
    param iComment :: "This clock function calls PRD_tick from within the on-chip timer ISR"
    param iDelUser :: "PRD"
    param iDelMsg  :: (
	"This object is automatically deleted by disabling the 'Use CLK Manager to drive PRD' option of PRD"
    )
}
 
type RTDX {
    isa ObjectMgr
    prop Label :: "RTDX - Real-Time Data Exchange Settings"
    prop name :: "RTDX"
    prop IsConfMod :: .USERTDX		
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 145
    prop InstanceIcon :: 146
    prop GlobalHelpTopic :: (
	113
    )
    prop InstanceHelpTopic :: (
	213	
    )
    prop InstancePropertyPage :: (		
	"{f80273c0-3838-11d2-a32c-006097656921}"
    )
    
    prop GlobalPropertyPage :: (		
	"{050a0600-3839-11d2-a32c-006097656921}"
    )
    prop AllocType :: (.USERTDX ?
	"2\0, _rtdxDataAllocDesc, _rtdxDataSeg, _placement,
	     _rtdxTextAllocDesc, _rtdxTextSeg, _placement"
	:
	""
    )
    prop _rtdxDataAllocDesc :: (
	" .%1L_data: {} \0, name"	
    )
    prop _rtdxTextAllocDesc :: (
	if (MEM.ENABLELOADSEG == 1) {
	    if (MEM.RTDXTEXTMEMSEG == MEM.LOADRTDXTEXTMEMSEG) {
		" .%1L_text: {} \0, name"	
	    }
	    else {
		" .%1L_text: {} load > %2s%3s, run \0, name, _loadRtdxTextMemSeg, _rtdx_textpg"
	    }
	}
	else {
	    " .%1L_text: {} \0, name"
	}
    )
    prop _rtdxDataSeg :: RTDX.DATAMEMSEG
    prop _rtdxTextSeg :: MEM.RTDXTEXTMEMSEG
    prop _loadRtdxTextMemSeg :: MEM.LOADRTDXTEXTMEMSEG
    prop _placement :: (0x7fffff / 2)
    prop _objSize :: RTDX.BUFMEMSIZE
    prop _rtdx_textpg :: (
        if (MEM.LOADRTDXTEXTMEMSEG.space() == "data") {
            " PAGE 1"
        }
        else {
            " PAGE 0"
        }
    )
    prop GenLinkPrologue :: (.USERTDX ?
         "_RTDX_interrupt_mask = 0x%1x;\n\0, _interruptMask"
	:
	""
    )
    prop _interruptMask :: RTDX.MASK
     
    prop cGen :: 1
    
    
 
    prop noObjectAlias :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "rtdx.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
            if (.iChannelMode == "output") {
	        "extern far RTDX_outputChannel %0r;\n\0"
	    }
	    else {
	        "extern far RTDX_inputChannel %0r;\n\0"
	    }
	}
        else {
            if (.iChannelMode == "output") {
                "extern RTDX_outputChannel %0r;\n\0"
	    }
	    else {
	        "extern RTDX_inputChannel %0r;\n\0"
	    }
        }
    )
    prop cGenCInst :: (
	if (.iChannelMode == "output") {
	    "RTDX_CreateOutputChannel(%0r);\n\0"
	}
	else {
	    "RTDX_CreateInputChannel(%0r);\n\0"
	}
    )
    prop dataSize :: (
	$d = 0,
	if (.USERTDX) {
	    $d = RTDX.BUFMEMSIZE
	}
	else {
	    $d = 0
	},
	scan ($a; RTDX) {
	    if ($a.iChannelMode == "output") {
		$d += 1
	    }
	    else {
		$d += 3
	    }
	},
	$d
    )
    prop localCanCreate :: (
	$e = "ok",
	if (RTDX.USERTDX != 1) {
	    $e = .error("RTDX manager not enabled")
	},
	$e
    )
    global USERTDX ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real-Time Data Exchange (RTDX)"
	prop JSName :: "ENABLERTDX"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
        prop Set :: (
            if($1 == 0) {
                if(HST.LNKTYPE == "RTDX") {
                    .error("RTDX is being used by HST; select a different host link type before attempting to disable RTDX") 
                }
                else {
		    if (.gNumOf > 0) {
			.error("Cannot disable RTDX until all RTDX objects are deleted.")
		    }
		    else {
		        GlobalStatus.gDirty = 1,    
                        .USERTDX = $1,
	                if (RTDX.CALLBACKOBJ != nil) {
		            RTDX.CALLBACKOBJ.call()
                        },
                        "ok"
		    }
                }
            }
	    else {
		GlobalStatus.gDirty = 1,	 
                .USERTDX = $1,
	        if (RTDX.CALLBACKOBJ != nil) {
		    RTDX.CALLBACKOBJ.call()
                },
                "ok"
	    }
        )
    }
    global USERTEXECUTION ::= 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Real-Time Execution Control"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global RTDXTYPE :: "JTAG" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "JTAG,Simulator"
	prop Label :: "RTDX Mode"
	prop JSName :: "MODE"
	prop Visible :: 1
	prop Writable :: .USERTDX
	prop NoGen :: 0
	prop Set :: (
	    .RTDXTYPE = $1,
	    if (RTDX.CALLBACKOBJ != nil) {
		RTDX.CALLBACKOBJ.call()
	    },
	    "ok"
	)
     }
    global DATAMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "RTDX Data Segment (.rtdx_data)"
	prop JSName :: "RTDXDATASEG"
	prop Visible :: 1
	prop Writable :: 1 
	prop NoGen :: 0
    }
    
 
    global BUFMEMSIZE ::= (256 + 2) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE) {  
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop Label :: "RTDX Buffer Size (MAUs)"
	prop JSName :: "BUFSIZE"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 0
        prop Set :: (
	    if (HST.RTDX == 0) {
                .BUFMEMSIZE = $1,
		GlobalStatus.gDirty = 1,	 
		"ok"
	    }
	    else {
                if ($1 < (HST.MAXFRAMESET + 3) * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) {
                    .error("size (in MAUs) must be at least: (largest configured HST channel framesize in words + 3) * (MAUs per word)")
                }
                else {
                    .BUFMEMSIZE = $1,
		    GlobalStatus.gDirty = 1, 	 
		    if (HST.LNKTYPE == "RTDX") {
			HST.MAXFRAMEALLOWED = (.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3,
			"ok"
		    }
		    else {
			"ok"
		    }
                }
	    }
        )
    }
    global TEXTMEMSEG :: H0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: (MEM.codeMember($1)) | (MEM.dataMember($1))
	prop Label :: "RTDX Text Segment (.rtdx_text)"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    global MASK :: 0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08x"
	prop Style :: 0x02
	prop Label :: "RTDX Interrupt Mask"
	prop JSName :: "INTERRUPTMASK"
	prop Visible :: 1
	prop Writable :: .USERTDX 
	prop NoGen :: 1
	prop Set :: (
	    .MASK = $1,
	    "ok"
	)
    }
    
    inst iChannelMode :: "output" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Channel Mode"
	prop JSName :: "channelMode"
	prop Enum :: "input,output"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    GlobalStatus.gDirty = 1,
	    .iChannelMode = $1,
	    "ok"
	)
    }
    
 
     global CALLBACKOBJ :: nil {
	 prop Visible :: 0
	 prop Writable :: 0
	 prop NoGen :: 1
    }
}
 
type HST {
    isa  ObjectMgr
    prop name :: "HST"
    prop Label :: "HST - Host Channel Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "PIE"
    prop FileStream :: 1
    prop GlobalIcon :: 107
    prop InstanceIcon :: 108
    prop GlobalHelpTopic :: (
	104
    )
    prop InstanceHelpTopic :: (
	204
    )
    prop maxObjs :: (
	GBL.DSPWORDSIZE
    )
    prop dataSize :: (
	$b = 0,
	scan ($i; HST) {
	    if ($i.IsConfObj()) {
		$b += ((6) + $i.framesize) * $i.numframes + PIP.OBJSIZE + .objectSize()
	    }
	},
	$b
    )
    prop InstancePropertyPage :: (
	    "{B7240DEA-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DEB-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    prop localCreate :: (
	PIP.gNumEmbed += 1,
	if (.gNumOf == 0) {
	    (LNK_dataPump.Create("HST"))
	},
     	"ok"
    )
    prop localDelete :: (
	PIP.gNumEmbed -= 1,
	$b = 0,			 
	scan ($i; HST) {
	    if ($i != self) {
	        if($i.IsConfObj()) {
	            if($i.framesize > $b) {
	                $b = $i.framesize 
	            } 
	        }
	    }
        },
	.MAXFRAMESET = $b,
	if (.gNumOf == 1) {
	    (LNK_dataPump.Delete("HST"))
	},
	"ok"
    )
    prop AllocType :: (
	"2\0, _globalAllocDesc, _memSeg, _placement, 	      _dsmAllocDesc, _dsmMemSeg, _placement"
    )
    
 
    prop _globalAllocDesc :: (
	"%8t .%1L: RUN_START(%1U_A_TABBEG), RUN_START(_%1U_A_TABBEG), RUN_END(%1U_A_TABEND), RUN_END(_%1U_A_TABEND) {%8t\n }\0, name"
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 28) {
	    $a = (14 * 1)
        }, 
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
	    $a = (12 * 1)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
	    $a = (12 * 1)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (10 * 1)
	},
	if (GBL.DSPTYPE == 54 || GBL.DSPTYPE == 62) {
	    $a = (7 * 1)
	},
	$a
    )
    prop _dsmAllocDesc :: (
	"%8t .dsm: {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop _instAllocDesc :: (
	"/* %0s buffer */\n.hst%2d: %3S\0, name, _objId, _alignString, _objAlign"
    )
    prop _alignString :: .bufalign > 1 ? "align = 0x%4x {}" : ""
    prop _objId :: .iId
    prop _objAlign :: .bufalign
    prop _objMemSeg :: .bufseg
    prop _linkString :: (.gNumOf + .gNumEmbed) > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: HST.OBJMEMSEG
    prop _dsmMemSeg :: HST.DSMBUFSEG
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "hst.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far HST_Obj %0r;\n\0"
	}
	else {
	    "extern HST_Obj %0r;\n\0"
        }
    )
    prop modifiable :: (
	(.iDelUser == "USER" ? 1 : 0)
    )
    global gNumEmbed :: 0 {      
        prop NoGen :: 1
    }
    global OBJMEMSEG :: L0SARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global LNKTYPE :: (
		if (0 == 0) {
		     "RTDX"
		}
		else {
		    if (0 == 1) {
			"Shared Memory"
		    }
		    else {
		        if (0 == 3) {
			    "EVM54"
		        }
		        else {
			    "NONE"
		        }
		    }
		} ) {
        prop Label :: "Host Link Type"
	prop JSName :: "HOSTLINKTYPE"
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "RTDX,NONE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
        prop Set :: (
	    if ($1 == "RTDX") {
		if (RTDX.USERTDX == 0) {
		    .error("RTDX module must be enabled before it can be used by HST")
		}
		else {
                    if ((RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 2 < .MAXFRAMESET) {
                        .error("RTDX buffer size too small for largest configured HST channel")
                    }
                    else {
			if (.LNKTYPE == "NONE") {
                    	    GlobalStatus.gDirty = 1,
                            .LNKTYPE = $1,
	    		    $b = 0,
	    		    scan ($i; HST) {
	        	        if($i.IsConfObj()) {
	             		    if($i.framesize > $b) {
	                 	        $b = $i.framesize 
	             	    	    } 
	         	        }
            		    },
			    .MAXFRAMESET = $b,
    			    .MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, 
                            "ok"
			}
			else {
                            .LNKTYPE = $1,
    			    .MAXFRAMEALLOWED = (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3, 
                            "ok"
			}
                    }
		}
	    }
	    else {
		if ($1 == "Shared Memory") {
                    if ((.DSMMEMSIZE/4) < .MAXFRAMESET) {
                        .error("Shared memory buffer too small for largest configured HST channel")
                    }
                    else {
			if (.LNKTYPE == "NONE") {
                    	    GlobalStatus.gDirty = 1,
                            .LNKTYPE = $1,
	    		    $b = 0,
	    		    scan ($i; HST) {
	        	        if ($i.IsConfObj()) {
	             		    if($i.framesize > $b) {
	                 	        $b = $i.framesize 
	             	    	    } 
	         	        }
            		    },
			    .MAXFRAMESET = $b,
    			    .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                            "ok"
			}
			else {
                            .LNKTYPE = $1,
    			    .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                            "ok"
			}
                    }
		}
		else {
                    GlobalStatus.gDirty = 1,
                    .LNKTYPE = $1,
                    "ok"
		}
            }
        )
    }
    global RTDX ::= .LNKTYPE == "RTDX" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use RTDX for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global DSM ::= .LNKTYPE == "Shared Memory" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Shared Memory for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global EVM54 ::= .LNKTYPE == "EVM54" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use EVM54's I/O ports for host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    global NONE ::= .LNKTYPE == "NONE" ? 1 : 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "No host link"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    global MAXFRAMESET ::= (
	    $b = 0,		 
	    scan ($i; HST) {
	        if($i.IsConfObj()) {
	             if($i.framesize > $b) {
	                 $b = $i.framesize 
	             } 
	         }
            }
	) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMESET"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 0
    }
    global MAXFRAMEALLOWED ::= .RTDX == 1 ? (RTDX.BUFMEMSIZE / (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)) - 3 : .DSMMEMSIZE /4 {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Label :: "MAXFRAMEALLOWED"
        prop Visible :: 0 	
        prop Writable :: 1
        prop NoGen :: 0
    }
    global DSMBUFSEG ::= .OBJMEMSEG {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Shared Memory Segment"
        prop Visible :: 0			
        prop Writable :: .DSM 
        prop NoGen :: 0
    }
 
    global DSMMEMSIZE ::= 1024 {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Style :: 0x01 | 0x02
        prop Label :: "Shared Memory Frame Size (MAUs)"
        prop Visible :: 0
        prop Writable :: .DSM
        prop NoGen :: 0
        prop Set :: (
            if ($1 < HST.MAXFRAMESET *4) {
                .error("size (in MAUs) must be at least: 4 * largest configured HST channel framesize (in words)")
            }
            else {
                .DSMMEMSIZE = $1,
                GlobalStatus.gDirty = 1,     
	        if (.LNKTYPE == "Shared Memory") {
	            .MAXFRAMEALLOWED  = .DSMMEMSIZE/4,
                    "ok"
		}
		else {
		    "ok"
		}
            }
        )
    }
    inst mode :: "output" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "mode"
	prop Enum :: "input,output"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 0
    }
    inst bufseg ::= .OBJMEMSEG {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "bufseg"
	prop JSName :: "bufSeg"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataNullMember($1)
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst bufalign :: 4 { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "bufAlign"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 1
	prop Set :: (	         
	    if ($1 < 4) {		 
	        .error("Alignment must be greater than or equal to 4")
	    }
	    else {
		if (($1 % 2) != 0) {  	 
	            .error("Alignment must be a power of 2")
		}
		else {
		    $i = $1,	 
		    while ((($i % 2) == 0) && ($i != 2)) {
		        $i = $i / 2
		    },
		    if(($i % 2) != 0) {	 
	                .error("Alignment must be a power of 2")
		    }
		    else {	     	 
		        .bufalign = $1,
	  	        "ok"
		    }
		}
	    }
	)
    }
    inst buf :: "<NULL>" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
    inst framesize :: 0x80 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "framesize (words)"
	prop JSName :: "frameSize"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("framesize must be >= 1.")
	    }
	    else {
		if (($1 > .MAXFRAMEALLOWED) && ((.RTDX == 1) || (.DSM == 1)) ) {
		    if (.RTDX == 1) {
		        .error("size (in words) is limited to: (RTDX buffer size in MAUs) / (MAUs per word) - 3")
		    }
		    else {
		            .error("size (in words) is limited to: shared memory frame size (in MAUs)/4")
		    }
		}
		else {
		    .framesize = $1,		 
		    $b = 0,			 
		    scan ($i; HST) {
	        	if($i.IsConfObj()) {
	            	    if($i.framesize > $b) {
	                	$b = $i.framesize 
	            	    } 
	        	}
        	    },
		    .MAXFRAMESET = $b,		 
	  	    GlobalStatus.gDirty = 1,	 
		    "ok"
		}
	    }
	)
    }
    inst numframes :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop JSName :: "numFrames"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("Channels must contain at least 1 frame.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.numframes = $1,
		"ok"
	    }
	)
    }
    inst stsflg :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "statistics"
	prop JSName :: "statistics"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst notify :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "DHL" || .iDelUser != "USER" ? 0 : 1)
	prop NoGen :: 0
	prop TabName :: "Notify Function"
    }
    
 
    inst lnk ::= .RTDX ? "RTDX" : "NOTRTDX" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "link type"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iDHLAvailable :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Make this channel available for a new DHL device"
	prop JSName :: "availableForDHL"
        prop Set :: (
	    if (($1 == 0) && (.iDHLAvailable == 1)) {
		DHL.gChannelsAvailable--
	    }
	    else {
		if (($1 == 1) && (.iDHLAvailable == 0)) {
		    DHL.gChannelsAvailable++
		}
	    },
	    .iDHLAvailable = $1,
	    "ok"
	)
	prop Writable :: .modifiable()
        prop Visible :: 1
	prop NoGen :: 1
    }
    
    inst bufFrameAlign ::= .bufalign  { 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
object LNK_dataPump :: IDL {
    param function :: @LNK_F_dataPump
    param cycles :: 0			 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
}
object RTA_dispatcher :: IDL {
    param function :: @RTA_F_dispatch
    param cycles :: 0			 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
}
object RTA_fromHost :: HST {
    param iComment  :: (
	"Used to access LOG and STS data"
    )
    param mode :: "input"
    param framesize :: 8 
    param numframes :: 1 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
    param iDHLAvailable :: 0 
} 
object RTA_toHost :: HST {
    param iComment  :: (
	"Used to access LOG and STS data"
    )
    param mode :: "output"
    param framesize :: 64 
    param numframes :: 1 
    param iDelUser :: "HST"
    param iDelMsg  :: (
	"This object cannot be deleted"
    )
    param iDHLAvailable :: 0
}
 
 
type HWI {
    isa  ObjectMgr
    prop name :: "HWI"
    prop Label :: "HWI - Hardware Interrupt Service Routine Manager"
    prop IsContainedIn :: SCH
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (
        205
    )
    
    prop GlobalHelpTopic :: (
        105
    )
    prop dataSize :: (
         0 * HWI.gNumOf
    )
    prop localCanCreate :: (
        .error("New hardware interrupt objects cannot be created")
    )
    prop InstancePropertyPage :: (
            "{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}"
    )
   
    prop GlobalPropertyPage :: (
            "{B7240DE7-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop DependsOn :: "GBL,OBJ,BUF,CLK,IDL,LCK,LOG,MBX,MEM,PIP,POOL,PRD,QUE,RTDX,SEM,STS,SYS"
   prop AllocType :: (
        "3\0,   _vectAllocDesc,         _vecSeg,        _minplace,
                _stubsAllocDesc,        _memSeg,        _placement,
                _dispAllocDesc,         _dispSeg,       _placement "
    )
   prop  _dispAllocDesc :: (
        "%8t .hwi_disp_sec:     {}"
                )
    prop _stubsAllocDesc :: (
        if ((MEM.ENABLELOADSEG) && (MEM.STUBMEMSEG != MEM.LOADSTUBMEMSEG)) {
            "%8t .%1L: {%8t\n%2S\n%8t} load > %3s%4s, run\0, name, _linkString, _loadstubSeg, _loadstubSegPg"
        }
        else {
            "%8t .%1L: {%8t\n%2S\n%8t} \0, name, _linkString"
        }
    )
    prop _vectAllocDesc :: (
        if(MEM.ENABLELOADSEG ) {
           if( HWI.VECMEMSEG == MEM.LOADVECMEMSEG) {
              "%8t .%1L_vec: START(_hwi_vec_loadstart), END(_hwi_vec_loadend), SIZE(_hwi_vec_loadsize), RUN_START(_hwi_vec_runstart) {\n%8t%2s\n%8t}\0, name, _linkerString"
                
           }
           else {
              "%8t .%1L_vec: START(_hwi_vec_loadstart), END(_hwi_vec_loadend), SIZE(_hwi_vec_loadsize), RUN_START(_hwi_vec_runstart) {\n%8t%2s\n%8t} load > %3s%4s, run\0, name, _linkerString,_loadvecSeg,_pageString2"
           }
        }
        else {
          "%8t .%1L_vec: START(_hwi_vec_loadstart), END(_hwi_vec_loadend), SIZE(_hwi_vec_loadsize), RUN_START(_hwi_vec_runstart) {\n%8t%2s\n%8t} \0, name, _linkerString"
                
        }
    )
        
    prop _placement :: (0x7fffff / 2)
    prop _minplace  :: 0
    prop localInit :: (
        if (RTDX.CALLBACKOBJ != nil) {
            .error("HWI initialization failure.")
        },
        RTDX.CALLBACKOBJ = HWI
    )
    prop call :: (
        if ( RTDX.USERTDX == 0 ) {
            HWI_DLOG.function = @HWI_unused
        }
        else {
            HWI_DLOG.function = @RTDX_F_isr
        }
    )
   
    
    prop _pageString :: (
        if( HWI.VECMEMSEG.space() == "data") {
                 " PAGE 1"
        }
        else{
                 " PAGE 0"
        }
    )
    prop _loadstubSegPg   :: (
        if( MEM.LOADSTUBMEMSEG.space() == "data") {
                 " PAGE 1"
        }
        else{
                 " PAGE 0"
        }
    )
    prop _pageString2   :: (
        if( MEM.LOADVECMEMSEG.space() == "data") {
                 " PAGE 1"
        }
        else{
                 " PAGE 0"
        }
    )
    
    prop _memSeg :: MEM.STUBMEMSEG
    prop _loadstubSeg :: MEM.LOADSTUBMEMSEG
    prop _linkString :: (
        $b = 0,
        scan ($a; HWI) {
            if ($a.monitor != "Nothing") {
                $b = 1
            }
        },
        if ($b == 1) {
            "*(.hwi)"
        }
        else {
            "/* no HWI stubs are necessary */"
        }
    )
    prop _linkerString :: (
        $b = 0,
        scan ($a; HWI) {
            if ($a.monitor != "Nothing") {
                $b = 1
            }
        },
        if ($b == 1) {
            "*(.hwi_vec)"
        }
        else {
            "/* no HWI stubs are necessary */"
        }
    )
    
    prop name2addr :: (
        $i = 0,
        $b = nil,
        scan ($a; { "Nothing","Data Value","Stack Pointer","acc","ah","al","xar0","xar1","xar2","xar3","xar4","xar5","xar6","xar7","dp","ifr","ier","ph","pl","st0","st1","t","tl"}) {             
            if ($b == nil) {             
                if ($a == $1) {          
                    $b = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}[$i]     
                },
                $i++
            }
        },
        if ($b == nil) {                 
            $b = 0                       
        },
        $b
    )
    
    prop name2type :: (
        $i = 0,
        $b = nil,
        scan ($a; { "Nothing","Data Value","Stack Pointer","acc","ah","al","xar0","xar1","xar2","xar3","xar4","xar5","xar6","xar7","dp","ifr","ier","ph","pl","st0","st1","t","tl"}) {             
            if ($b == nil) {             
                if ($a == $1) {          
                    if ($i < 5) {
                        $b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i]  
                    }
                },
                $i++
            }
        },
        if ($b == nil) {                 
            $b = "unsigned"              
        },
        $b
    )
    
    global STUBMEMSEG :: H0SARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: (MEM.codeMember($1)) | (MEM.dataMember($1))
        prop Label :: "Function Stub Memory"
        prop Visible :: 0
        prop Writable :: 1
        prop NoGen :: 1
    }
    prop _dispSeg :: MEM.BSSSEG 
     
    global VMAPSELECT :: 1 {
            prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
            prop Label :: "VMAP Mode"
            prop JSName :: "VMAPMODE"
            prop Enum :: "0,1"
            prop Visible :: GBL.DSPTYPE == 28
            prop Writable :: 1
            prop NoGen :: 0
            prop Set :: (
                if ( $1 == 0 ) {
                        if ( .PIESELECT == 1 ) {
                        .VMAPSELECT = 1,
                        .warning(" VMAP Mode should be 1 while PIE is enabled"),
                        "ok"
                        }
                        else {
                        .VMAPSELECT = $1,
                        "ok"
                        }
                }
                else {
                        .VMAPSELECT = $1,
                        "ok"
                }
            )
        }       
    global VECMEMSEG ::= PIEVECT {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop Label :: "Interrupt Service Table Memory"
        prop Visible :: 0
        prop Writable :: 0 
        prop NoGen :: 1
        prop MemberTest :: .codeMember($1)
        prop Set :: (
                .VECMEMSEG = $1,
                "ok"
                )
    }
    global PIESELECT :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Enable PIE"
        prop JSNAME :: "enablePIE"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
        prop Set :: (
                if ( $1 == 1 ) {
                        if ( .VMAPSELECT == 0 ) {
                        .PIESELECT = $1,
                        .VMAPSELECT = 1,
                        .warning ("Enabling PIE requires VMAP Mode 1"),
                        "ok"
                        }
                        else {
                        .PIESELECT = $1,
                        "ok"
                        }
                }
                else {
                        .PIESELECT = $1,
                        "ok"
                }
        )
    }
    prop _vecSeg :: MEM.VECMEMSEG
    prop _loadvecSeg :: MEM.LOADVECMEMSEG
    inst function :: @HWI_unused {
        prop JSName :: "fxn"
        prop Visible :: 1
        prop Writable :: (( .function == @RESERVED ) ||
                ( .client != "USER" )) ? 0 : 1
        prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
        prop NoGen :: 0
        prop Set :: (
                .function = $1,
                GlobalStatus.gDirty = 1,
                "ok"
        )
    }
    inst iSTSObj :: HWI_RESETSTS {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    inst monitor :: "Nothing" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "Nothing,Data Value"
        prop JSName :: "monitor"
        prop Visible :: 1
        prop Writable :: ((.function != @HWI_unused && .function != @RESERVED) && (.iId != 0))
        prop NoGen :: 0
        prop Set :: (
            if ($1 != .monitor) {        
                $e = "ok",
                if ($1 == "Nothing") {
                    if (($e = .iSTSObj.Delete("HWI")) == "ok") {
                        .monitor = "Nothing",
                        .addr = .name2addr(.monitor),
                        .dataType = .name2type(.monitor)
                    }
                }
                else {
                    if (.iSTSObj.iIsUsed || ($e = .iSTSObj.Create("HWI")) == "ok") {
                        .monitor = $1,
                        if (.monitor == "Data Value") {
                            .addr = .saveAddr,
                            .dataType = .saveType
                        }
                        else {
                            .addr = .name2addr(.monitor),
                            .dataType = .name2type(.monitor)
                        }
                    }
                    else {
                        .monitor = "Nothing"
                    }
                },
                $e
            }
            else {
                "ok"
            }
        )
    }
    inst saveAddr :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    inst saveType :: "signed" {
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    
    inst addr :: 0 {
        prop JSName :: "addr"
        prop Visible :: 1
        prop Writable :: (.monitor == "Data Value" ? 1 : 0)
        prop NoGen :: 0
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Format :: GBL.DSPTYPE == 62 ? "0x%08x" : "0x%04x"
        prop Set :: (
            .addr = $1,
            .saveAddr = $1,
            "ok"
        )
    }
    inst dataType :: "signed" {
        prop Visible :: 1
        prop Writable :: (.monitor == "Nothing" ? 0 : 1)
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Enum :: "signed,unsigned"
        prop Label :: "type"
        prop JSName :: "dataType"
        prop Set :: (
            if (.monitor != "Nothing") {
                .dataType = $1,
                .saveType = $1,
                "ok"
            }
            else {
                .error("The monitor field must set to modify this field")
            }
        )
    }
    inst operation :: "STS_add(*addr)" {
        prop Visible :: 1
        prop Writable :: (.monitor == "Nothing" ? 0 : 1)
        prop NoGen :: 0
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop JSName :: "operation"
        prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
        prop Set :: (
            if (.monitor != "Nothing") {
                .operation = $1,
                "ok"
            }
            else {
                .error("The monitor field must set to modify this field")
            }
        )
    }
    inst client :: "USER" {
        prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 0
    }
     
     
     inst iUseDispatcher :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Use Dispatcher"
        prop JSName :: "useDispatcher"
        prop Visible :: 1
        prop Writable :: ( .client == "USER" ) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ( .function == @CLK_F_isr ) {
                .error("This HWI is being used by the system and cannot be modified")
            }
            else {
                .iUseDispatcher = $1,
                "ok"
            }
        )
     }
 
     inst iArg :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label :: "Arg"
        prop JSName :: "arg"
        prop Visible :: 1
        prop Writable :: (( .iUseDispatcher == 1 ) && ( .client == "USER" )) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (
            .iArg = $1,
            "ok"
        )
     }
 
     inst iIerMask :: "self" {
        prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "Interrupt Mask IER"
        prop JSName :: "interruptMask0"
        prop Enum :: "all,none,self,bitmask"
        prop Visible :: 1
        prop Writable :: ( .iUseDispatcher == 1 ) ? 1 : 0
        prop NoGen :: 1
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ( $1 == "all" ) {
                .IerMask = 0xffff
            }
            else {
                if ( $1 == "self" ) {
                   if ((.iId < 17)  && ( .iId > 0 )) {
                        .IerMask = (1 << (.iId - 1) )
                   }
                   else {
                        .warning("This Interrupt is NOT maskable via IER")
                        .IerMask = 0
                   }
                }
                else {
                    if ( $1 == "none" ) {
                        .IerMask = 0
                    }
                }
            },
            .iIerMask = $1,
            "ok"
        )
     }
        
     inst IerMask :: (.iId > 16) ? 0 : (.iId < 1) ? 0 : (1 << (.iId - 1)) {
        prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
        prop Format :: "0x%04x"
        prop Style :: 0x02
        prop Label :: "Interrupt Bit Mask IER"
        prop JSName :: "interruptBitMask"
        prop Visible :: 1
        prop Writable :: ((.iUseDispatcher == 1) && (.iIerMask == "bitmask" )) ? 1 : 0
        prop NoGen :: 0
        prop TabName :: "Dispatcher"
        prop Set :: (
            if ( $1 > 0xffff) {
                .error("Invalid Number")
            }
            else {
                .IerMask = $1,
                "ok"
            }
        )
     }
 
}
object HWI_RESET_STS :: STS {
    param iComment :: "provides statistics for the RESET ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RESET :: HWI {
    param iComment :: "defines function for the RESET ISR"
    param iId :: 0                       
    
 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RESET_STS
}
object HWI_INT1_STS :: STS {
    param iComment :: "provides statistics for the INT1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT1 :: HWI {
    param iComment :: "defines the INT1 Interrupt"
    param iId :: 1                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT1_STS
}
object HWI_INT2_STS :: STS {
    param iComment :: "provides statistics for the INT2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT2 :: HWI {
    param iComment :: "defines the INT2 Interrupt"
    param iId :: 2                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT2_STS
}
object HWI_INT3_STS :: STS {
    param iComment :: "provides statistics for the INT3 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT3 :: HWI {
    param iComment :: "defines the INT3 Interrupt"
    param iId :: 3                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT3_STS
}
object HWI_INT4_STS :: STS {
    param iComment :: "provides statistics for the INT4 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT4 :: HWI {
    param iComment :: "defines the INT4 Interrupt"
    param iId :: 4                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT4_STS
}
object HWI_INT5_STS :: STS {
    param iComment :: "provides statistics for the INT5 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT5 :: HWI {
    param iComment :: "defines the INT5 Interrupt"
    param iId :: 5                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT5_STS
}
object HWI_INT6_STS :: STS {
    param iComment :: "provide statistics for  INT6  Interrupt"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT6 :: HWI {
    param iComment :: "defines the INT6 Interrupt"
    param iId :: 6                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT6_STS
}
object HWI_INT7_STS :: STS {
    param iComment :: "provides statistics for the INT7 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT7 :: HWI {
    param iComment :: "defines the INT7 Interrupt"
    param iId :: 7                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT7_STS
}
object HWI_INT8_STS :: STS {
    param iComment :: "provides statistics for the INT8 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT8 :: HWI {
    param iComment :: "defines the INT8 Interrupt"
    param iId :: 8                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT8_STS
}
object HWI_INT9_STS :: STS {
    param iComment :: "provides statistics for the INT 9  ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT9:: HWI {
    param iComment :: "defines the INT9  Interrupt"
    param iId :: 9                       
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT9_STS
}
object HWI_INT10_STS :: STS {
    param iComment :: "provides statistics for the INT10 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT10 :: HWI {
    param iComment :: "defines the INT10 Interrupt"
    param iId :: 10                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT10_STS
}
object HWI_INT11_STS :: STS {
    param iComment :: "provides statistics for the INT11 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT11 :: HWI {
    param iComment :: "defines the INT11 Interrupt"
    param iId :: 11                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT11_STS
}
object HWI_INT12_STS :: STS {
    param iComment :: "provides statistics for the INT12 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_INT12 :: HWI {
    param iComment :: "defines the INT12 Interrupt"
    param iId :: 12                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT12_STS
}
object HWI_INT13 :: HWI {
    param iComment :: "defines the INT13 Interrupt"
    param iId :: 13                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_INT13_STS
}
object HWI_TINT_STS :: STS {
    param iComment :: "provides statistics for the INT14 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_TINT :: HWI {
    param iComment :: "defines the INT14 Interrupt"
    param iId :: 14                      
    param iIsUsed :: 1                   
    param function :: @CLK_F_isr
    param client :: "CLK"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_TINT_STS
}
object HWI_DLOG_STS :: STS {
    param iComment :: "provides statistics for the DLOGINT ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_DLOG :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iId :: 15                      
    param function :: (RTDX.USERTDX ==1) ? @RTDX_F_isr : @HWI_unused
    param client :: "RTDX"
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_DLOG_STS
}
object HWI_RTOS_STS :: STS {
    param iComment :: "provides statistics for the RTOSINT ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RTOS :: HWI {
    param iComment :: "defines the RTOS Interrupt"
    param iId :: 16                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RTOS_STS
}
object HWI_RESERVED_STS :: STS {
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_RESERVED :: HWI {
    param iComment :: "RESERVED for RTDX"
    param iId :: 17                      
    param client :: "RTDX"
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_RESERVED_STS
}
object HWI_NMI_STS :: STS {
    param iComment :: "provides statistics for the NMI ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_NMI :: HWI {
    param iComment :: "defines function for the NMI ISR"
    param iId :: 18                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_NMI_STS
}
object HWI_ILLEGAL_STS :: STS {
    param iComment :: "provides statistics for the ILLEGAL ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_ILLEGAL :: HWI {
    param iComment :: "defines function for the ILLEGAL ISR"
    param iId :: 19                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_ILLEGAL_STS
}
object HWI_USER1_STS :: STS {
    param iComment :: "provides statistics for the INT15 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER1 :: HWI {
    param iComment :: "defines the USER1 Interrupt"
    param iId :: 20                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER1_STS
}
object HWI_USER2_STS :: STS {
    param iComment :: "provides statistics for the INT16 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER2 :: HWI {
    param iComment :: "defines the USER2 Interrupt"
    param iId :: 21                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER2_STS
}
object HWI_USER3_STS :: STS {
    param iComment :: "provides statistics for the INT17 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER3 :: HWI {
    param iComment :: "defines the USER3 Interrupt"
    param iId :: 22                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER3_STS
}
object HWI_USER4_STS :: STS {
    param iComment :: "provides statistics for the INT18 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER4 :: HWI {
    param iComment :: "defines the USER4 Interrupt"
    param iId :: 23                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER4_STS
}
object HWI_USER5_STS :: STS {
    param iComment :: "provides statistics for the INT19 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER5 :: HWI {
    param iComment :: "defines the USER5 Interrupt"
    param iId :: 24                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER5_STS
}
object HWI_USER6_STS :: STS {
    param iComment :: "provides statistics for the USER6 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER6 :: HWI {
    param iComment :: "defines the USER6 Interrupt"
    param iId :: 25                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER6_STS
}
object HWI_USER7_STS :: STS {
    param iComment :: "provides statistics for the  ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER7 :: HWI {
    param iComment :: "defines the USER7 Interrupt"
    param iId :: 26                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER7_STS
}
object HWI_USER8_STS :: STS {
    param iComment :: "provides statistics for the  ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER8 :: HWI {
    param iComment :: "defines the USER8 Interrupt"
    param iId :: 27                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER8_STS
}
object HWI_USER9_STS :: STS {
    param iComment :: "provides statistics for the USER9 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER9 :: HWI {
    param iComment :: "defines the USER9 Interrupt"
    param iId :: 28                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER9_STS
}
object HWI_USER10_STS :: STS {
    param iComment :: "provides statistics for the USER10INT ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER10 :: HWI {
    param iComment :: "defines the USER10 Interrupt"
    param iId :: 29                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER10_STS
}
object HWI_USER11_STS :: STS {
    param iComment :: "provides statistics for the USER11 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER11 :: HWI {
    param iComment :: "defines the USER11 Interrupt"
    param iId :: 30                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER11_STS
}
object HWI_USER12_STS :: STS {
    param iComment :: "provides statistics for the USER12 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "This STS object is being used by a HWI object and cannot be deleted"
    )
}
object HWI_USER12 :: HWI {
    param iComment :: "defines the USER12 Interrupt"
    param iId :: 31                      
    param iIsUsed :: 1                   
    param iDelUser :: "HWI"
    param iDelMsg :: (
        "Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: HWI_USER12_STS
}
 
 
type PIE {
    isa	 ObjectMgr
    prop name :: "PIE"
    prop Label :: "PIE INTERRUPTS"
    prop IsContainedIn :: HWI
    prop SortChildHierView :: 0
    prop GlobalIcon :: 109
    prop InstanceIcon :: 110
    prop InstanceHelpTopic :: (
	205
    )
    
    prop GlobalHelpTopic :: (
	105
    )
    prop dataSize :: (
	 0 * HWI.gNumOf
    )
    prop localCanCreate :: (
	.error("New hardware interrupt objects cannot be created")
    )
    prop InstancePropertyPage :: (
	    "{B7240DE6-AA51-11cf-9BFE-0000C0AC14C7}"
    )
   
    prop DependsOn :: "HWI"
    
    prop name2addr :: (
	$i = 0,
	$b = nil,
	scan ($a; { "Nothing","Data Value","Stack Pointer","acc","ah","al","xar0","xar1","xar2","xar3","xar4","xar5","xar6","xar7","dp","ifr","ier","ph","pl","st0","st1","t","tl"}) {		 
	    if ($b == nil) {		 
		if ($a == $1) {		 
		    $b = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}[$i]	 
		},
		$i++
	    }
	},
	if ($b == nil) {		 
	    $b = 0			 
	},
	$b
    )
    
    prop name2type :: (
	$i = 0,
	$b = nil,
	scan ($a; { "Nothing","Data Value","Stack Pointer","acc","ah","al","xar0","xar1","xar2","xar3","xar4","xar5","xar6","xar7","dp","ifr","ier","ph","pl","st0","st1","t","tl"}) {		 
	    if ($b == nil) {		 
		if ($a == $1) {		 
		    if ($i < 5) {
			$b = {"unsigned", "signed", "unsigned", "unsigned", "unsigned"}[$i]  
		    }
		},
		$i++
	    }
	},
	if ($b == nil) {		 
	    $b = "unsigned"		 
	},
	$b
    )
    
    inst function :: @HWI_unused {
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (( .function == @RESERVED ) || ( .client != "USER" ) || (HWI.PIESELECT == 0)) ? 0 : 1
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop NoGen :: 0
	prop Set :: (
		.function = $1,
		GlobalStatus.gDirty = 1,
		"ok"
	)
    }
    inst iSTSObj :: HWI_RESETSTS {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst monitor :: "Nothing" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Nothing,Data Value"
	prop JSName :: "monitor"
	prop Visible :: 1
	prop Writable :: ((.function != @HWI_unused && .function != @RESERVED) && (.iId != 0))
	prop NoGen :: 0
	prop Set :: (
	    if ($1 != .monitor) {	 
		$e = "ok",
		if ($1 == "Nothing") {
		    if (($e = .iSTSObj.Delete("HWI")) == "ok") {
			.monitor = "Nothing",
			.addr = .name2addr(.monitor),
			.dataType = .name2type(.monitor)
		    }
		}
		else {
		    if (.iSTSObj.iIsUsed || ($e = .iSTSObj.Create("HWI")) == "ok") {
			.monitor = $1,
			if (.monitor == "Data Value") {
			    .addr = .saveAddr,
			    .dataType = .saveType
			}
			else {
			    .addr = .name2addr(.monitor),
			    .dataType = .name2type(.monitor)
			}
		    }
		    else {
			.monitor = "Nothing"
		    }
		},
		$e
	    }
	    else {
		"ok"
	    }
	)
    }
    inst saveAddr :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst saveType :: "signed" {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
    inst addr :: 0 {
	prop JSName :: "addr"
	prop Visible :: 1
	prop Writable :: (.monitor == "Data Value" ? 1 : 0)
	prop NoGen :: 0
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Format :: "0x%04x"
	prop Set :: (
	    .addr = $1,
	    .saveAddr = $1,
	    "ok"
	)
    }
    inst dataType :: "signed" {
	prop Visible :: 1
	prop Writable :: (.monitor == "Nothing" ? 0 : 1)
	prop NoGen :: 0
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "signed,unsigned"
	prop Label :: "type"
	prop JSName :: "dataType"
	prop Set :: (
	    if (.monitor != "Nothing") {
		.dataType = $1,
		.saveType = $1,
		"ok"
	    }
	    else {
		.error("The monitor field must set to modify this field")
	    }
	)
    }
    inst operation :: "STS_add(*addr)" {
	prop Visible :: 1
	prop Writable :: (.monitor == "Nothing" ? 0 : 1)
	prop NoGen :: 0
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "operation"
	prop Enum :: "STS_add(*addr),STS_delta(*addr),STS_add(-*addr),STS_delta(-*addr),STS_add(|*addr|),STS_delta(|*addr|)"
	prop Set :: (
	    if (.monitor != "Nothing") {
		.operation = $1,
		"ok"
	    }
	    else {
		.error("The monitor field must set to modify this field")
	    }
	)
    }
    inst client :: "USER" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     
     
     inst iUseDispatcher :: 0 {
 	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
 	prop Label :: "Use Dispatcher"
	prop JSName :: "useDispatcher"
 	prop Visible :: 1
 	prop Writable :: ( .client == "USER" ) ? 1 : 0
 	prop NoGen :: 0
 	prop TabName :: "Dispatcher"
 	prop Set :: (
 	    if ( .function == @CLK_F_isr ) {
 		.error("This HWI is being used by the system and cannot be modified")
 	    }
 	    else {
 		.iUseDispatcher = $1,
 		"ok"
 	    }
 	)
     }
 
     inst iArg :: 0 {
 	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
 	prop Label :: "Arg"
	prop JSName :: "arg"
 	prop Visible :: 1
 	prop Writable :: (( .iUseDispatcher == 1 ) && ( .client == "USER" )) ? 1 : 0
 	prop NoGen :: 0
 	prop TabName :: "Dispatcher"
 	prop Set :: (
 	    .iArg = $1,
 	    "ok"
 	)
     }
 
     inst iIerMask :: "self" {
 	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
 	prop Label :: "Interrupt Mask IER0"
	prop JSName :: "interruptMask0"
 	prop Enum :: "all,none,self,bitmask"
 	prop Visible :: 1
 	prop Writable :: ( .iUseDispatcher == 1 ) ? 1 : 0
 	prop NoGen :: 1
 	prop TabName :: "Dispatcher"
 	prop Set :: (
 	    if ( $1 == "all" ) {
 		.IerMask = 0xffff
 	    }
 	    else {
 		if ( $1 == "self" ) {
		   .IerMask = ( 1 << ((.iId - 32) >> 3) )
 		}
 		else {
 		    if ( $1 == "none" ) {
 			.IerMask = 0
 		    }
 		}
 	    },
 	    .iIerMask = $1,
 	    "ok"
 	)
     }
 	
     inst IerMask :: ( 1 << ((.iId - 32) >> 3) ) {
 	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
 	prop Format :: "0x%04x"
 	prop Style :: 0x02
 	prop Label :: "Interrupt Bit Mask IER"
	prop JSName :: "interruptBitMask"
 	prop Visible :: 1
 	prop Writable :: ((.iUseDispatcher == 1) && (.iIerMask == "bitmask" )) ? 1 : 0
 	prop NoGen :: 0
 	prop TabName :: "Dispatcher"
 	prop Set :: (
 	    if ( $1 > 0xffff) {
 		.error("Invalid Number")
 	    }
 	    else {
 		.IerMask = $1,
 		"ok"
 	    }
 	)
     }
 
}   
object PIE_INT1_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT1.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT1_1 :: PIE {
    param iComment :: "defines function for the PIE_INT1.1"
    param iId :: 32			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT1_1_STS
}
object PIE_INT1_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT1.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT1_2 :: PIE {
    param iComment :: "defines function for the PIE_INT1.2"
    param iId :: 33			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT1_2_STS
}
object PIE_INT1_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT1.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT1_3 :: PIE {
    param iComment :: "defines function for the PIE_INT1.3"
    param iId :: 34			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT1_3_STS
}
object PIE_INT1_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT1.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT1_4 :: PIE {
    param iComment :: "defines function for the PIE_INT1.4"
    param iId :: 35			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT1_4_STS
}
object PIE_INT1_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT1.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT1_5 :: PIE {
    param iComment :: "defines function for the PIE_INT1.5"
    param iId :: 36			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT1_5_STS
}
object PIE_INT1_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT1.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT1_6 :: PIE {
    param iComment :: "defines function for the PIE_INT1.6"
    param iId :: 37			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT1_6_STS
}
object PIE_INT1_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT1.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT1_7 :: PIE {
    param iComment :: "defines function for the PIE_INT1.7"
    param iId :: 38			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT1_7_STS
}
object PIE_INT1_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT1.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT1_8 :: PIE {
    param iComment :: "defines function for the PIE_INT1.8"
    param iId :: 39			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT1_8_STS
}
object PIE_INT2_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT2.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT2_1 :: PIE {
    param iComment :: "defines function for the PIE_INT2.1"
    param iId :: 40			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT2_1_STS
}
object PIE_INT2_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT2.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT2_2 :: PIE {
    param iComment :: "defines function for the PIE_INT2.2"
    param iId :: 41			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT2_2_STS
}
object PIE_INT2_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT2.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT2_3 :: PIE {
    param iComment :: "defines function for the PIE_INT2.3"
    param iId :: 42			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT2_3_STS
}
object PIE_INT2_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT2.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT2_4 :: PIE {
    param iComment :: "defines function for the PIE_INT2.4"
    param iId :: 43			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT2_4_STS
}
object PIE_INT2_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT2.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT2_5 :: PIE {
    param iComment :: "defines function for the PIE_INT2.5"
    param iId :: 44			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT2_5_STS
}
object PIE_INT2_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT2.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT2_6 :: PIE {
    param iComment :: "defines function for the PIE_INT2.6"
    param iId :: 45			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT2_6_STS
}
object PIE_INT2_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT2.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT2_7 :: PIE {
    param iComment :: "defines function for the PIE_INT2.7"
    param iId :: 46			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT2_7_STS
}
object PIE_INT2_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT2.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT2_8 :: PIE {
    param iComment :: "defines function for the PIE_INT2.8"
    param iId :: 47			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT2_8_STS
}
object PIE_INT3_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT3.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT3_1 :: PIE {
    param iComment :: "defines function for the PIE_INT3.1"
    param iId :: 48			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT3_1_STS
}
object PIE_INT3_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT3.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT3_2 :: PIE {
    param iComment :: "defines function for the PIE_INT3.2"
    param iId :: 49			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT3_2_STS
}
object PIE_INT3_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT3.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT3_3 :: PIE {
    param iComment :: "defines function for the PIE_INT3.3"
    param iId :: 50			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT3_3_STS
}
object PIE_INT3_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT3.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT3_4 :: PIE {
    param iComment :: "defines function for the PIE_INT3.4"
    param iId :: 51			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT3_4_STS
}
object PIE_INT3_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT3.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT3_5 :: PIE {
    param iComment :: "defines function for the PIE_INT3.5"
    param iId :: 52			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT3_5_STS
}
object PIE_INT3_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT3.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT3_6 :: PIE {
    param iComment :: "defines function for the PIE_INT3.6"
    param iId :: 53			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT3_6_STS
}
object PIE_INT3_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT3.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT3_7 :: PIE {
    param iComment :: "defines function for the PIE_INT3.7"
    param iId :: 54			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT3_7_STS
}
object PIE_INT3_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT3.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT3_8 :: PIE {
    param iComment :: "defines function for the PIE_INT3.8"
    param iId :: 55			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT3_8_STS
}
object PIE_INT4_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT4.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT4_1 :: PIE {
    param iComment :: "defines function for the PIE_INT4.1"
    param iId :: 56			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT4_1_STS
}
object PIE_INT4_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT4.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT4_2 :: PIE {
    param iComment :: "defines function for the PIE_INT4.2"
    param iId :: 57			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT4_2_STS
}
object PIE_INT4_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT4.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT4_3 :: PIE {
    param iComment :: "defines function for the PIE_INT4.3"
    param iId :: 58			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT4_3_STS
}
object PIE_INT4_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT4.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT4_4 :: PIE {
    param iComment :: "defines function for the PIE_INT4.4"
    param iId :: 59			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT4_4_STS
}
object PIE_INT4_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT4.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT4_5 :: PIE {
    param iComment :: "defines function for the PIE_INT4.5"
    param iId :: 60			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT4_5_STS
}
object PIE_INT4_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT4.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT4_6 :: PIE {
    param iComment :: "defines function for the PIE_INT4.6"
    param iId :: 61			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT4_6_STS
}
object PIE_INT4_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT4.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT4_7 :: PIE {
    param iComment :: "defines function for the PIE_INT4.7"
    param iId :: 62			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT4_7_STS
}
object PIE_INT4_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT4.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT4_8 :: PIE {
    param iComment :: "defines function for the PIE_INT4.8"
    param iId :: 63			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT4_8_STS
}
object PIE_INT5_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT5.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT5_1 :: PIE {
    param iComment :: "defines function for the PIE_INT5.1"
    param iId :: 64			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT5_1_STS
}
object PIE_INT5_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT5.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT5_2 :: PIE {
    param iComment :: "defines function for the PIE_INT5.2"
    param iId :: 65			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT5_2_STS
}
object PIE_INT5_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT5.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT5_3 :: PIE {
    param iComment :: "defines function for the PIE_INT5.3"
    param iId :: 66			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT5_3_STS
}
object PIE_INT5_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT5.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT5_4 :: PIE {
    param iComment :: "defines function for the PIE_INT5.4"
    param iId :: 67			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT5_4_STS
}
object PIE_INT5_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT5.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT5_5 :: PIE {
    param iComment :: "defines function for the PIE_INT5.5"
    param iId :: 68			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT5_5_STS
}
object PIE_INT5_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT5.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT5_6 :: PIE {
    param iComment :: "defines function for the PIE_INT5.6"
    param iId :: 69			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT5_6_STS
}
object PIE_INT5_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT5.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT5_7 :: PIE {
    param iComment :: "defines function for the PIE_INT5.7"
    param iId :: 70			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT5_7_STS
}
object PIE_INT5_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT5.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT5_8 :: PIE {
    param iComment :: "defines function for the PIE_INT5.8"
    param iId :: 71			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT5_8_STS
}
object PIE_INT6_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT6.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT6_1 :: PIE {
    param iComment :: "defines function for the PIE_INT6.1"
    param iId :: 72			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT6_1_STS
}
object PIE_INT6_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT6.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT6_2 :: PIE {
    param iComment :: "defines function for the PIE_INT6.2"
    param iId :: 73			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT6_2_STS
}
object PIE_INT6_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT6.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT6_3 :: PIE {
    param iComment :: "defines function for the PIE_INT6.3"
    param iId :: 74			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT6_3_STS
}
object PIE_INT6_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT6.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT6_4 :: PIE {
    param iComment :: "defines function for the PIE_INT6.4"
    param iId :: 75			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT6_4_STS
}
object PIE_INT6_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT6.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT6_5 :: PIE {
    param iComment :: "defines function for the PIE_INT6.5"
    param iId :: 76			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT6_5_STS
}
object PIE_INT6_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT6.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT6_6 :: PIE {
    param iComment :: "defines function for the PIE_INT6.6"
    param iId :: 77			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT6_6_STS
}
object PIE_INT6_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT6.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT6_7 :: PIE {
    param iComment :: "defines function for the PIE_INT6.7"
    param iId :: 78			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT6_7_STS
}
object PIE_INT6_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT6.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT6_8 :: PIE {
    param iComment :: "defines function for the PIE_INT6.8"
    param iId :: 79			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT6_8_STS
}
object PIE_INT7_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT7.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT7_1 :: PIE {
    param iComment :: "defines function for the PIE_INT7.1"
    param iId :: 80			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT7_1_STS
}
object PIE_INT7_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT7.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT7_2 :: PIE {
    param iComment :: "defines function for the PIE_INT7.2"
    param iId :: 81			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT7_2_STS
}
object PIE_INT7_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT7.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT7_3 :: PIE {
    param iComment :: "defines function for the PIE_INT7.3"
    param iId :: 82			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT7_3_STS
}
object PIE_INT7_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT7.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT7_4 :: PIE {
    param iComment :: "defines function for the PIE_INT7.4"
    param iId :: 83			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT7_4_STS
}
object PIE_INT7_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT7.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT7_5 :: PIE {
    param iComment :: "defines function for the PIE_INT7.5"
    param iId :: 84			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT7_5_STS
}
object PIE_INT7_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT7.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT7_6 :: PIE {
    param iComment :: "defines function for the PIE_INT7.6"
    param iId :: 85			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT7_6_STS
}
object PIE_INT7_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT7.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT7_7 :: PIE {
    param iComment :: "defines function for the PIE_INT7.7"
    param iId :: 86			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT7_7_STS
}
object PIE_INT7_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT7.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT7_8 :: PIE {
    param iComment :: "defines function for the PIE_INT7.8"
    param iId :: 87			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT7_8_STS
}
object PIE_INT8_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT8.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT8_1 :: PIE {
    param iComment :: "defines function for the PIE_INT8.1"
    param iId :: 88			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT8_1_STS
}
object PIE_INT8_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT8.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT8_2 :: PIE {
    param iComment :: "defines function for the PIE_INT8.2"
    param iId :: 89			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT8_2_STS
}
object PIE_INT8_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT8.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT8_3 :: PIE {
    param iComment :: "defines function for the PIE_INT8.3"
    param iId :: 90			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT8_3_STS
}
object PIE_INT8_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT8.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT8_4 :: PIE {
    param iComment :: "defines function for the PIE_INT8.4"
    param iId :: 91			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT8_4_STS
}
object PIE_INT8_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT8.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT8_5 :: PIE {
    param iComment :: "defines function for the PIE_INT8.5"
    param iId :: 92			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT8_5_STS
}
object PIE_INT8_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT8.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT8_6 :: PIE {
    param iComment :: "defines function for the PIE_INT8.6"
    param iId :: 93			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT8_6_STS
}
object PIE_INT8_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT8.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT8_7 :: PIE {
    param iComment :: "defines function for the PIE_INT8.7"
    param iId :: 94			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT8_7_STS
}
object PIE_INT8_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT8.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT8_8 :: PIE {
    param iComment :: "defines function for the PIE_INT8.8"
    param iId :: 95			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT8_8_STS
}
object PIE_INT9_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT9.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT9_1 :: PIE {
    param iComment :: "defines function for the PIE_INT9.1"
    param iId :: 96			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT9_1_STS
}
object PIE_INT9_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT9.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT9_2 :: PIE {
    param iComment :: "defines function for the PIE_INT9.2"
    param iId :: 97			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT9_2_STS
}
object PIE_INT9_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT9.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT9_3 :: PIE {
    param iComment :: "defines function for the PIE_INT9.3"
    param iId :: 98			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT9_3_STS
}
object PIE_INT9_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT9.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT9_4 :: PIE {
    param iComment :: "defines function for the PIE_INT9.4"
    param iId :: 99			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT9_4_STS
}
object PIE_INT9_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT9.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT9_5 :: PIE {
    param iComment :: "defines function for the PIE_INT9.5"
    param iId :: 100			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT9_5_STS
}
object PIE_INT9_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT9.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT9_6 :: PIE {
    param iComment :: "defines function for the PIE_INT9.6"
    param iId :: 101			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT9_6_STS
}
object PIE_INT9_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT9.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT9_7 :: PIE {
    param iComment :: "defines function for the PIE_INT9.7"
    param iId :: 102			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT9_7_STS
}
object PIE_INT9_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT9.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT9_8 :: PIE {
    param iComment :: "defines function for the PIE_INT9.8"
    param iId :: 103			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT9_8_STS
}
object PIE_INT10_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT10.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT10_1 :: PIE {
    param iComment :: "defines function for the PIE_INT10.1"
    param iId :: 104			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT10_1_STS
}
object PIE_INT10_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT10.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT10_2 :: PIE {
    param iComment :: "defines function for the PIE_INT10.2"
    param iId :: 105			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT10_2_STS
}
object PIE_INT10_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT10.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT10_3 :: PIE {
    param iComment :: "defines function for the PIE_INT10.3"
    param iId :: 106			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT10_3_STS
}
object PIE_INT10_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT10.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT10_4 :: PIE {
    param iComment :: "defines function for the PIE_INT10.4"
    param iId :: 107			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT10_4_STS
}
object PIE_INT10_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT10.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT10_5 :: PIE {
    param iComment :: "defines function for the PIE_INT10.5"
    param iId :: 108			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT10_5_STS
}
object PIE_INT10_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT10.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT10_6 :: PIE {
    param iComment :: "defines function for the PIE_INT10.6"
    param iId :: 109			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT10_6_STS
}
object PIE_INT10_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT10.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT10_7 :: PIE {
    param iComment :: "defines function for the PIE_INT10.7"
    param iId :: 110			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT10_7_STS
}
object PIE_INT10_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT10.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT10_8 :: PIE {
    param iComment :: "defines function for the PIE_INT10.8"
    param iId :: 111			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT10_8_STS
}
object PIE_INT11_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT11.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT11_1 :: PIE {
    param iComment :: "defines function for the PIE_INT11.1"
    param iId :: 112			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT11_1_STS
}
object PIE_INT11_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT11.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT11_2 :: PIE {
    param iComment :: "defines function for the PIE_INT11.2"
    param iId :: 113			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT11_2_STS
}
object PIE_INT11_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT11.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT11_3 :: PIE {
    param iComment :: "defines function for the PIE_INT11.3"
    param iId :: 114			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT11_3_STS
}
object PIE_INT11_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT11.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT11_4 :: PIE {
    param iComment :: "defines function for the PIE_INT11.4"
    param iId :: 115			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT11_4_STS
}
object PIE_INT11_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT11.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT11_5 :: PIE {
    param iComment :: "defines function for the PIE_INT11.5"
    param iId :: 116			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT11_5_STS
}
object PIE_INT11_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT11.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT11_6 :: PIE {
    param iComment :: "defines function for the PIE_INT11.6"
    param iId :: 117			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT11_6_STS
}
object PIE_INT11_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT11.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT11_7 :: PIE {
    param iComment :: "defines function for the PIE_INT11.7"
    param iId :: 118			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT11_7_STS
}
object PIE_INT11_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT11.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT11_8 :: PIE {
    param iComment :: "defines function for the PIE_INT11.8"
    param iId :: 119			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT11_8_STS
}
object PIE_INT12_1_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT12.1 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT12_1 :: PIE {
    param iComment :: "defines function for the PIE_INT12.1"
    param iId :: 120			 
    param iIsUsed :: 1
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT12_1_STS
}
object PIE_INT12_2_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT12.2 ISR"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT12_2 :: PIE {
    param iComment :: "defines function for the PIE_INT12.2"
    param iId :: 121			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT12_2_STS
}
object PIE_INT12_3_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT12.3"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT12_3 :: PIE {
    param iComment :: "defines function for the PIE_INT12.3"
    param iId :: 122			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT12_3_STS
}
object PIE_INT12_4_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT12.4"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT12_4 :: PIE {
    param iComment :: "defines function for the PIE_INT12.4"
    param iId :: 123			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT12_4_STS
}
object PIE_INT12_5_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT12.5"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT12_5 :: PIE {
    param iComment :: "defines function for the PIE_INT12.5"
    param iId :: 124			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT12_5_STS
}
object PIE_INT12_6_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT12.6"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT12_6 :: PIE {
    param iComment :: "defines function for the PIE_INT12.6"
    param iId :: 125			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT12_6_STS
}
object PIE_INT12_7_STS :: STS {
    param iComment :: "provide statistics for  PIE_INT12.7"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT12_7 :: PIE {
    param iComment :: "defines function for the PIE_INT12.7"
    param iId :: 126			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT12_7_STS
}
object PIE_INT12_8_STS :: STS {
    param iComment :: "provides statistics for the PIE_INT12.8"
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"This STS object is being used by a HWI object and cannot be deleted"
    )
}
object PIE_INT12_8 :: PIE {
    param iComment :: "defines function for the PIE_INT12.8"
    param iId :: 127			 
    param iIsUsed :: 1			 
    param iDelUser :: "HWI"
    param iDelMsg :: (
	"Hardware interrupt objects cannot be deleted"
    )
    param iSTSObj :: PIE_INT12_8_STS
}
 
type SWI {
    isa	ObjectMgr
    prop name :: "SWI"
    prop Label :: "SWI - Software Interrupt Manager"
    prop IsContainedIn :: SCH
    prop DependsOn :: "PIE,SIO,HST,MSGQ"
    prop GlobalIcon :: 123
    prop InstanceIcon :: 124
    prop InstanceHelpTopic :: (
	211
    )
    
    prop GlobalHelpTopic :: (
	111
    )
    
 
    prop HighTimeBased :: (
        CLK.HIRES == 1 ? 1 : 0
    )
    prop LowTimeBased :: (
        CLK.HIRES == 1 ? 0 : 1
    )
    
 
    prop uType :: (
        if (.HighTimeBased()) {
	    $a = 0
        }
        else {
	    if (.LowTimeBased()) {
	        $a = 1
	    }
	    else {
	        $a = 2
            }
        },
        $a
    )
    
 
    prop STSGetMaxFmt :: (
	if (SWI.STSUNITS == "raw") {
	    CLK.HIRES ? "%g inst" : "%g ints"
	}
	else {
	    SWI.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSGetSumFmt :: (
	SWI.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	if (SWI.STSUNITS == "raw") {
	    CLK.HIRES ? "%.2f inst" : "%.2f ints"
	}
	else {
	    SWI.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
 
    prop STSFilterMaxMult :: (
	$a = 1
    )
    prop STSFilterSumMult :: (
	SWI.STSFilterMaxMult($1)
    )
    
 
    prop GetPriority :: (
	.pri
    )
    prop objectSize :: (
	if ((GBL.DSPTYPE == 54 && GBL.FARMODE == 0) ||
		(GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL")) {
	    $a = (12 * 1)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (14 * 1)
	},
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (20 * 1)
	},
	if (GBL.DSPTYPE == 62) {
	    $a = (11 * 1)
	},
	$a
    )
    prop GenLinkPrologue :: (
	"SECTIONS {%4t\n.swi: RUN_START(SWI_A_TABBEG), RUN_END(SWI_A_TABEND) {%4t\n} > %1s%2s\0, memSeg, pageString"
    )
    prop GenLinkEpilogue :: (
    	"%0t}\nSWI_A_TABLEN = %1d;\n\0, numInst"
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62
                      ? ""
                      : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
                      ? (
                          SWI.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : SWI.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : SWI.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )
                      :" PAGE 1"
    prop memSeg :: SWI.OBJMEMSEG
     
    prop objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop maxObjs :: (
	32767				 
    )
    prop numInst :: (
    	SWI.gNumOf
    )
    prop dataSize :: (
	.objectSize() * SWI.gNumOf
    )
    prop localCanCreate :: (
	if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
	    .error("System stack size (see MEM) is too small to support a new SWI priority level.")
	}
	else {
	    "ok"
	}
    )
    prop localCreate :: (
	STS.gNumEmbed += 1,
	SWI.EXECFXN = @SWI_F_exec,
	SWI.RUNFXN = @SWI_F_run,
	"ok"
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	if (.gNumOf == 1) {	 
	     
	    SWI.EXECFXN = @FXN_F_nop,
	    SWI.RUNFXN = @FXN_F_nop
	},
	"ok"
    )
    prop SortByField :: "pri"
    prop SortGroups :: 15
    prop InstancePropertyPage :: (
	    "{B7240DEC-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DED-AA51-11cf-9BFE-0000C0AC14C7}"
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "swi.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far SWI_Obj %0r;\n\0"
	}
	else {
	    "extern SWI_Obj %0r;\n\0"
	}
    )
    global EHOOKFXN :: @GBL_NULL {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Enable Scheduler and Return to Idle Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global IHOOKFXN :: @GBL_NULL {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit Scheduler and Return to Idle Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    global EXECFXN :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Configured SWI executive"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global RUNFXN :: @FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Configured SWI executive body"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global STSUNITS :: "raw" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "raw,milliseconds,microseconds"
	prop Label :: "Statistics Units"
	prop Visible :: 0		 
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst priority :: = (.pri + 1) {
        prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Label :: "priority"
	prop JSName :: ""
        prop Visible :: 0
        prop Writable :: 0
        prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst pri :: 1 {		 
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	 
	prop Enum :: "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14"
	prop Label :: "priority"
	prop JSName :: "priority"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
            $a = .pri,
            .pri = $1,
	    if (self == KNL_swi) {
		if ($1 != 0) {
		    .pri = $a,
		    .error("KNL_swi must remain at Priority 0.")
		}
		else {
		    "ok"
		}
	    }
	    else {
		if ($1 == 0 && KNL_swi.iIsUsed == 1) {
		    .pri = $a,
		    .error("Priority 0 reserved for KNL_swi only.")
		}
		else {
		    GlobalStatus.gDirty = 1,
		    if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
			.pri = $a,
			.error("System stack size (see MEM) is too small to support a new SWI priority level.")
		    }
		    else {
			if ($1 > 14) {
			    .pri = $a,
			    .error("SWI can only support 15 priority levels.")
			}
			else {
			    "ok"
			}
		    }
		}
	    }
	)
    }
    inst mailbox :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01 | 0x02
	prop JSName :: "mailbox"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst arg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst arg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst dorta :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 0
	prop Writable :: 1
     }
    
 
    inst filter :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    inst maxformat :: .STSGetMaxFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: .STSGetSumFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: .STSGetAvgFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    inst filtmaxmult :: 1  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtmaxmult"
	prop NoGen :: 0
    }
    inst filtsummult :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtsummult"
	prop NoGen :: 0
    }
    inst unittype :: .uType() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "unittype"
	prop NoGen :: 0
    }
}    
 
type TSK {
    isa ObjectMgr
    prop name :: "TSK"
    prop Label :: "TSK - Task Manager"
    prop IsConfMod :: .USETSK
    prop IsContainedIn :: SCH
    
 
    prop DependsOn :: "SWI,HOOK"
    prop GlobalIcon :: 143
    prop InstanceIcon :: 144
    prop GlobalHelpTopic :: (
	314
    )
    prop InstanceHelpTopic :: (
	414
    )
    prop InstancePropertyPage :: (
	"{473C4A64-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A65-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop SortByField :: "iPRI"
    prop SortGroups :: 17
    prop objectSize :: (
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (27 * 1)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
	    $a = (44 * 1)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
	    $a = (44 * 1)
	},
	if (GBL.DSPTYPE == 28) {
	    $a = (40 * 1)
	},
	if (GBL.DSPTYPE == 62 || (GBL.DSPTYPE == 54 && GBL.FARMODE == 0)) {
	    $a = (24 * 1)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (25 * 1)
	},
	$a
    )
    prop GenLinkPrologue :: (
	if (.USETSK != 0) {
	    "SECTIONS {%4t\n.%1L: {%8t\n %4S %4t\n} > %3s%5s\0, name, objSize, _bssmemSeg, linkString, pageString"
	}
	else {
	    "_KNL_swi = 0;"
	}
    )
    prop linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop pageString :: GBL.DSPTYPE == 62
                      ? ""
                      : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
                      ? (
                          TSK.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : TSK.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : TSK.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )
                      :" PAGE 1"
    prop GenLinkEpilogue :: (
	if (.USETSK != 0) {
	    "%0t}\n\0"
	}
        else {
            ""
        }
    )
    prop _objAllocDesc :: (    
	"%8t .TSK$obj: {}"
    )
    prop _bssmemSeg :: .OBJMEMSEG
    prop _objmemSeg :: MEM.CFGOBJSEG	 
    prop AllocInst :: (
	.iAUTOSTK ? "1\0, _instStackDesc, _instStackSeg, _placement" : "0\0"
    )
    prop _instStackDesc :: (
	"%8t .%0s$stk: {%12t\n *(.%0s$stk)%8t\n }\0"
    )
    prop _self :: self
    prop _instStackSize :: .iSTKSZ * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    prop _instStackSeg :: .iSTKSEG
    prop _placement :: (0x7fffff / 2)
    prop localInit :: (
	KNL_swi.Create("SWI"),
	if (.STACKSEG.iAllocHeap == 1) {
	    .STACKSEG.iReqHeapCount++,
	    "ok"
	}
	else {
	    .error ("TSK default stack segment must be a memory segment with a heap")
	}
    )
    
 
    prop HighTimeBased :: (
        CLK.HIRES == 1 ? 1 : 0
    )
    prop LowTimeBased :: (
        CLK.HIRES == 1 ? 0 : 1
    )
    
 
    prop uType :: (
        if (.HighTimeBased()) {
	    $a = 0
        }
        else {
	    if (.LowTimeBased()) {
	        $a = 1
	    }
	    else {
	        $a = 2
	    }
        },
        $a
    )
    
 
    prop STSGetMaxFmt :: (
	if (TSK.STSUNITS == "raw") {
	    CLK.HIRES ? "%g inst" : "%g ints"
	}
	else {
	    TSK.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
    prop STSGetSumFmt :: (
	TSK.STSGetMaxFmt()
    )
    prop STSGetAvgFmt :: (
	if (TSK.STSUNITS == "raw") {
	    CLK.HIRES ? "%.2f inst" : "%.2f ints"
	}
	else {
	    TSK.STSUNITS == "microseconds" ? "%.1f us" : "%.2f ms"
	}
    )
     
    prop STSFilterMaxMult :: (
	$a = 1
    )
    prop STSFilterSumMult :: (
	TSK.STSFilterMaxMult($1)
    )
    prop localCreate :: (
	STS.gNumEmbed += 1,
	"ok"
    )
    prop localCanCreate :: (
	$e = "ok",
	if (TSK.USETSK != 1) {
	    $e = .error("TSK manager not enabled")
	},
	$e
    )
    prop localDelete :: (
	STS.gNumEmbed -= 1,
	"ok"
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "tsk.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far TSK_Obj %0r;\n\0"
        }
	else {
	    "extern TSK_Obj %0r;\n\0"
        }
    )
    prop NOPFXN :: @FXN_F_nop
    global USETSK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable TSK Manager"
	prop JSName :: "ENABLETSK"
	prop Visible :: 1
	prop Writable :: GBL.DSPSUBTYPE == 0x55DA200 ? 0:1
	prop NoGen :: 1
	prop Set :: (
	    if ($1 == 0) {
		if (.gNumOf > 1) {
		    .error("Cannot disable TSK until all TSK objects are deleted.")
		}
		else {
		    .STACKSEG.iReqHeapCount--,
		    TSK.STACKSEG = MEM_NULL,	 
		    TSK.OBJMEMSEG = MEM_NULL,
		    TSK_idle.iSTKSEG = MEM_NULL,
		    TSK_idle.Delete("TSK"),
		    KNL_swi.Delete("TSK"),
		    PRD.THOOKFXN = .NOPFXN,
                    if (PRD.gNumOf == 0) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @FXN_F_nop
                      }
                    },
		    .USETSK = $1,
		    "ok"
		}
	    } else {
		$e = "ok",
	        GlobalStatus.gDirty = 1,
	        if (GlobalStatus.MinStackSize >= MEM.STACKSIZE) {
                    $e = .error("Current stack size inadequate to enable TSK"),
		    break
		    },
		scan ($a; SWI) {
		    if ($a != KNL_swi && $a.pri == 0 && $a.iIsUsed == 1) {
			$e = .error("Cannot enable TSK when there are SWI objects at Priority 0."),
			break
		    }
		},
		if ($e == "ok") {
		    TSK.STACKSEG = MEM_NULL,   
		    scan($b; MEM) {
			if ($b.iAllocHeap && $b != MEM_NULL) {
		    	     
		    	    TSK.STACKSEG = $b,
			    break
			}
		    },
		    .STACKSEG.iReqHeapCount++,
		    .USETSK = $1,
		    				 
		    TSK.OBJMEMSEG = SWI.OBJMEMSEG,
		    TSK_idle.iSTKSEG = .OBJMEMSEG,   
		    TSK_idle.Create("TSK"),
		    KNL_swi.Create("TSK"),
		    PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN,
                    if (TSK.TSKTICK == "PRD") {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @PRD_F_tick
                      }
                    },
		    if ( MEM.NOHEAPS ) {
			.STACKSEG.iReqHeapCount++
		    },
		    $e
		}
		else {
		    $e
		}
	    }
	)
    }
     
    prop _objId :: .iId
    prop objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop dataSize :: (
	$d = 0,
	scan ($i; TSK) {
	    
 
	    $d += ($i.iSTKSZ + .objectSize() * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE))
	},
	$d
    )
     
    prop minStackSize :: (
	$a = .STACKSIZE,
	scan ($i; TSK) {
	    if ($i.STACKSIZE < $a) {
		$a = $i.STACKSIZE
	    }
	},
	$a
    )
    prop maxObjs :: (32767)			 
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "OBJMEMSEG"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataNullMember($1)
	prop Label :: "Object Memory"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop NoGen :: 1
    }
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global STACKSIZE :: GBL.DSPTYPE == 62 ? 1024 : 
			(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE == 5599) ? 2560 :
			(GBL.DSPTYPE == 55 && GBL.DSPSUBTYPE != 5599) ? 1024 :
			(GBL.DSPTYPE == 28) ? 256 : 256 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: GBL.DSPTYPE == 54 ? 0x01 : 0x02
	prop Label :: "Default stack size (MAUs)"
	prop JSName :: "STACKSIZE"
	prop Visible :: 1
	prop Writable :: .USETSK
    }	
    
    global STACKSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataNullMember($1) && (($1.base + $1.len) <= 0x10000) && $1.iAllocHeap
	prop Label :: "Stack segment for dynamic tasks"
	prop JSName :: "STACKSEG"
	prop Visible :: 1
	prop Writable :: .USETSK && (MEM.NOHEAPS == 0)
	prop Set :: (
	    if (.STACKSEG.iReqHeapCount > 0) {
		.STACKSEG.iReqHeapCount--
	    },
	    .STACKSEG = $1,
	    .STACKSEG.iReqHeapCount++,
	    "ok"
	)
    }	
    global PRIORITY :: 1 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "PRIORITY"
	prop Enum :: "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
	prop Label :: "Default task priority"
	prop Visible :: 1
	prop Writable :: .USETSK
    }
    global CREATEFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create function"
	prop JSName :: "CREATEFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .CREATEFXN = $1,
	    HOOK_KNL.createFxn = .CREATEFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VCREATEFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doCreate : .CREATEFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global DELETEFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete function"
	prop JSName :: "DELETEFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .DELETEFXN = $1,
	    HOOK_KNL.deleteFxn = .DELETEFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VDELETEFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doDelete : .DELETEFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global EXITFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit function"
	prop JSName :: "EXITFXN"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop TabName :: "Function Hooks"
	prop Set :: (
	    .EXITFXN = $1,
	    HOOK_KNL.exitFxn = .EXITFXN,
	    "ok"
	)
	prop NoGen :: 1
    }
    global VEXITFXN ::= HOOK_KNL.iIsUsed == 1 ? @__HOOK_doExit : .EXITFXN {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global DOSWITCH :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call switch function"
	prop JSName :: "CALLSWITCHFXN"
	prop Writable :: .USETSK
	prop Visible :: 1
	prop NoGen :: 1
	prop Set :: (
	    .DOSWITCH = $1,
	    HOOK_KNL.callSwitchFxn = .DOSWITCH,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global VSWFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Switch function"
	prop JSName :: "SWITCHFXN"
	prop Visible :: 1
	prop NoGen :: 1
	prop Writable :: .DOSWITCH && .USETSK
	prop Set :: (
	    .VSWFXN = $1,
	    HOOK_KNL.switchFxn = .VSWFXN,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global SWITCHFXN ::= (
	 
	if (HOOK_KNL.iIsUsed) {
	    $i = 0,
	     
	    scan ($a; HOOK) {
		if ($a.callSwitchFxn) {
		    $i = 1
		}
	    },
	     
	    if ($i) {
		@__HOOK_doSwitch
	    }
	    else {
		0
	    }
	}
	else {
	    if (.DOSWITCH) {
		.VSWFXN
	    }
	    else {
		0
	    }
	}
    ) {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: ""
	prop TabName :: "Function Hooks"
    }
    global DOREADY :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call ready function"
	prop JSName :: "CALLREADYFXN"
	prop Writable :: .USETSK
	prop Visible :: 1
	prop NoGen :: 1
	prop Set :: (
	    .DOREADY = $1,
	    HOOK_KNL.callReadyFxn = .DOREADY,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global VRDYFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Ready function"
	prop JSName :: "READYFXN"
	prop Visible :: 1
	prop Writable :: .DOREADY && .USETSK
	prop NoGen :: 1
	prop Set :: (
	    .VRDYFXN = $1,
	    HOOK_KNL.readyFxn = .VRDYFXN,
	    "ok"
	)
	prop TabName :: "Function Hooks"
    }
    global READYFXN ::= (
	 
	if (HOOK_KNL.iIsUsed) {
	    $i = 0,
	     
	    scan ($a; HOOK) {
		if ($a.callReadyFxn) {
		    $i = 1
		}
	    },
	     
	    if ($i) {
		@__HOOK_doReady
	    }
	    else {
		0
	    }
	}
	else {
	    if (.DOREADY) {
		.VRDYFXN
	    }
	    else {
		0
	    }
	}
    ) {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: ""
	prop TabName :: "Function Hooks"
    }
    global NUM_HOOKS ::= HOOK.gNumOf {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
    }
    global STSUNITS :: "raw" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "raw,milliseconds,microseconds"
	prop Label :: "Statistics Units"
	prop Visible :: 0
	prop Writable :: .USETSK
	prop NoGen :: 1
    }
    
    global TSKTICK :: "PRD" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "PRD,User"
	prop Label :: "TSK tick driven by"
	prop JSName :: "DRIVETSKTICK"
	prop Visible :: 1
	prop Writable :: .USETSK
	prop NoGen :: 1
	prop Set :: (
	    if ($1 != .TSKTICK) {
		if ($1 == "PRD") {
                    PRD.THOOKFXN = PRD.DEFAULT_THOOKFXN,
                    if (TSK.USETSK == 1) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @PRD_F_tick
                      }
                    }
		},
		if ($1 == "User") {
                    PRD.THOOKFXN = .NOPFXN,
                    if (PRD.gNumOf == 0) {
                      if (PRD_clock.iIsUsed == 1) {
                        PRD_clock.function = @FXN_F_nop
                      }
                    }
		},
		if ($1 != "PRD" && $1 != "User") {
		    .error ("Invalid TSK tick driver selection")
		}
	    },
	    .TSKTICK = $1,
	    "ok"
	)
    }
    
    
 
    prop GetPriority :: (
	.iPRI
    )
    
     
    inst iFXN :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Task function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG0 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 0"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG1 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 1"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG2 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 2"
	prop JSName :: "arg2"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG3 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 3"
	prop JSName :: "arg3"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG4 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 4"
	prop JSName :: "arg4"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG5 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 5"
	prop JSName :: "arg5"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG6 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 6"
	prop JSName :: "arg6"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    inst iARG7 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "Task function argument 7"
	prop JSName :: "arg7"
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
	prop TabName :: "Function"
    }
    
 
    inst iAUTOSTK :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Automatically allocate stack"
	prop JSName :: "autoAllocateStack"
        prop Set :: (
            if (($1 == 1) && (.iAUTOSTK == 0)) {
                .iSTKSZ = TSK.STACKSIZE
            },
            .iAUTOSTK = $1,
            "ok"
        )
	prop Visible :: 1
	prop Writable :: .iDelUser == "TSK" ? 0 : 1
    }
    
 
    inst iMANSTK :: @null {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Manually allocated stack"
	prop JSName :: "manualStack"
	prop Visible :: 1
	prop Writable :: .iAUTOSTK == 0
    }
    inst iSTKSZ :: TSK.STACKSIZE {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: GBL.DSPTYPE == 54 ? 0x01 : 0x02
	prop Label :: "Stack size (MAUs)"
	prop JSName :: "stackSize"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    $a = $1,
	    if ($a < 32) {
	        if (GBL.DSPSUBTYPE == 62) {
		    .error("Task stack size is too small.")
		}	
		else {
		    if ($a < 32) {
		        .error("Task stack size is too small.")
		    }
		    else {
		        .iSTKSZ = ($1 - ($1 - 1) % 8 + 7),
 	                 GlobalStatus.gDirty = 1,
	                 "ok"
		    }
		}
	    }
	    else {
	        .iSTKSZ = ($1 - ($1 - 1) % 8 + 7),
 	        GlobalStatus.gDirty = 1,
	        "ok"
	    }
	)
    }
   
 
    
    inst iSTKSEG ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
        prop MemberTest :: ($1 == MEM_NULL || MEM.dataNullMember($1)) && (($1.base + $1.len) <= 0x10000)
	prop Label :: "Stack Memory Segment"
	prop JSName :: "stackMemSeg"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iPRI :: TSK.PRIORITY {
	prop Label :: "Priority"
	prop JSName :: "priority"
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if (self == TSK_idle) {
		if ($1 == 0) {
		    "ok"
		}
		else {
		    .error("Cannot change the priority of the idle task.")
		}
	    }
	    else {
	    if ($1 == 0) {
		.error("Priority 0 is reserved for the system idle task")
	    }
	    else {
		.iPRI = $1,
		"ok"
	    }
	    }
	)
    }
    inst iENV :: 0 {
        prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Environment pointer"
	prop JSName :: "envPointer"
	prop Visible :: 1
	prop Writable :: .iDelUser != "TSK"
	prop TabName :: "Advanced"
    }
    inst iEXITFLAG :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Don't shut down system while this task is still running"
	prop JSName :: "exitFlag"
	prop Visible :: 1
	prop Writable :: 1
	prop TabName :: "Advanced"
    }
    inst iUSETSKNAME :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Allocate Task Name on Target"
	prop JSName :: "allocateTaskName"
	prop Visible :: 1
	prop Writable :: 1
	prop TabName :: "Advanced"
    }
    inst iSTATREG :: 0x0000 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "0x%08x"
	prop Label :: "Initial Status Register value"
	prop Visible :: 0
	prop Writable :: 1
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 0
	prop Writable :: 1
    }
    
 
    inst filter :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    inst maxformat :: .STSGetMaxFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: .STSGetSumFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: .STSGetAvgFmt() {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    inst filtmaxmult :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtmaxmult"
	prop NoGen :: 0
    }
    inst filtsummult :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filtsummult"
	prop NoGen :: 0
    }
    inst unittype :: .uType() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "unittype"
	prop NoGen :: 0
    }
}
object TSK_idle :: TSK {
    param iComment :: "This is the idle task; it only runs when no other task is ready"
    param iDelUser :: "TSK"
    param iDelMsg :: "This task executes all IDL functions and cannot be deleted"
    param iFXN :: GBL.DSPTYPE == 54
		? @_IDL_loop
		: @IDL_F_loop
    param iPRI :: 0
    param iIsUsed :: TSK.USETSK
}
 
object KNL_swi :: SWI {
    param function :: @_KNL_run
    param iComment :: "This Software Interrupt calls the TSK scheduler"
    param iDelUser :: "TSK"
    param iIsUsed :: TSK.USETSK
    param iDelMsg  :: (
        "This object cannot be deleted in DSP/BIOS."
    )
    param pri :: 0
    param dorta :: 1
}
 
type IDL {
    isa ObjectMgr
    prop Label :: "IDL - Idle Function Manager"
    prop name :: "IDL"
    prop IsContainedIn :: SCH
    prop GlobalIcon :: 111
    prop InstanceIcon :: 112
    prop GlobalHelpTopic :: (
	106
    )
    prop InstanceHelpTopic :: (
	206
    )
    prop InstancePropertyPage :: (
	"{586735F1-770B-11d0-A61F-0000C070F3E9}"
    )
    
    prop GlobalPropertyPage :: (
	"{586735F0-770B-11d0-A61F-0000C070F3E9}"
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28) {
	     $a = (2 * 1)
	}
	else {
	     $a = (1 * 1)
	},
	$a
    )
    prop GenLinkPrologue :: (
        "SECTIONS {%4t\n.%1L: {%8t\n %4S %4t\n} > %3s%5s, RUN_START(%1U_A_TABBEG)\0, name, _objSize, _memSeg, _linkString, _pageString"
    )
    prop GenLinkEpilogue :: (
        "%4t\n.%1Lcal: {%8t\n %4S %4t\n} > %3s%5s, RUN_START(%1U_A_CALBEG) %0t\n}\n%6S\n\0, name, _objSize, _memSeg, _linkCalString, _pageString, _nilBusyObj"
    )
    prop _linkString :: "*(.%1L)" 
    prop _linkCalString :: "*(.%1Lcal)"
    prop _pageString :: GBL.DSPTYPE == 62 
                      ? "" 
                      : (GBL.DSPTYPE == 55  || GBL.DSPTYPE == 28)
                      ? ( 
                          IDL.OBJMEMSEG.space() == "code"
                          ? " PAGE 0"
                          : IDL.OBJMEMSEG.space() == "data"
                            ? " PAGE 1"
                            : IDL.OBJMEMSEG.space() == "io"
                              ? " PAGE 2"
                              : " PAGE 0"
                        )       
                      :" PAGE 1"
    prop _nilBusyObj :: ( ((IDL.USEIDLBUSYOBJ == 0) && (GBL.ROM == 1)) ?
         "IDL_busyObj = 0;\n"
        :
         ""
    )
    prop _memSeg :: IDL.OBJMEMSEG
     
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop dataSize :: (
	.objectSize() * (IDL.gNumOf + 1)	 
    )
    prop maxObjs :: (
	32767				 
    )
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    
 
    prop idlFxnSum :: (
	$a = 0,
	scan ($i; IDL) {
	   $a += $i.cycles
	},
	$a
    )
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
 
    global AUTOCALCULATE :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Auto calculate idle loop instruction count"
	prop JSName :: "AUTOCALCULATE"
	prop Visible :: 1
	prop Writable :: CLK.USETIMER
	prop Set :: (
	    if ($1 == 1 && CLK.USETIMER == 0) {
		.error("CLK must be enabled to do idle loop intruction count")
	    }
	    else {
		if ($1 == 1 && GBL.ENABLEINST == 0) {
		    .error("Real Time Analysis must be enabled to do idle loop instruction count")
		}
		else {
		    .AUTOCALCULATE = $1,
		    "ok"
		}
	    }
	)
	prop NoGen :: 1
    }
    
 
    global USECLKIDLTIME ::= IDL.AUTOCALCULATE {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    
 
    global USEIDLBUSYOBJ ::= 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    
 
 
    global CALIBRFXN :: = (
	if (IDL.AUTOCALCULATE == 1) {
	    TSK.USETSK ?  @IDL_F_stub : @IDL_F_calibrate
	}
	else {
	    @GBL_NULL
	}
    ) {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Idle Loop Auto-Calibrate Function"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
    
 
    global CALIBRERROR :: = (
	if (GBL.DSPTYPE == 62 && IDL.CALIBRFXN == @IDL_F_stub) {
	    6
	}
	else {
	    0
	}
    ) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Idle Loop Auto-Calibrate Error"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
    }
  
 
    global LOOPOVERHEAD :: 0 {
	prop Label :: "Idle Loop Instruction Count"
	prop JSName :: "LOOPINSTCOUNT"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .AUTOCALCULATE == 0
	prop NoGen :: 1
    }
    inst function :: @_FXN_F_nop {	 
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
    }
    inst cycles :: 0 {
	prop Label :: "CPU cycles"
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0		 
	prop Writable :: (.iDelUser == "USER") ? 1 : 0
	prop NoGen :: 1
    }
    inst calibration :: 1 {
	prop Label :: "Include in CPU load calibration"
	prop JSName :: "calibration"
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1		
	prop Writable :: (.iDelUser == "USER") ? 1 : 0
	prop NoGen :: 0
    }
     
    inst Order :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object IDL_cpuLoad :: IDL {
    param iComment :: "This object is required by the system to acquire CPU load data"
    param iId :: 0			
    param iIsUsed :: GBL.ENABLEINST
    param cycles :: 0			 
    param iDelUser :: "IDL"
    param iDelMsg :: (
	"This object is required to compute CPU load and can't be deleted"
    )
    param function :: @IDL_F_busy
}
object IDL_busyObj :: STS {
    param iComment :: "This object is required by the system to accumulate CPU load statistics"
    param iIsUsed :: GBL.ENABLEINST
    param iDelUser :: "IDL"
    param iDelMsg :: (
	"This object is required to accumulate CPU load data and can't be deleted"
    )
}
 
 
type LOG {
    isa  ObjectMgr
    prop name :: "LOG"
    prop Label :: "LOG - Event Log Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 113
    prop InstanceIcon :: 114
    prop InstanceHelpTopic :: (
	207
    )
    
    prop GlobalHelpTopic :: (
	107
    )
    prop InstancePropertyPage :: (
	"{B7240DE8-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DE9-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement" 
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: RUN_START(%1U_A_TABBEG), RUN_START(_%1U_A_TABBEG), RUN_END(%1U_A_TABEND), RUN_END(_%1U_A_TABEND) {%8t\n }\0, name"
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (10 * 1)
	},
	if (GBL.DSPTYPE == 62 || GBL.DSPTYPE == 54 ||
		(GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL")) {
	    $a = (6 * 1)
	},
	$a
    )
    prop _placement :: (0x7fffff / 2)
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop GenLinkEpilogue :: (
        "%0tLOG_A_TABLEN = %1d; _LOG_A_TABLEN = %1d;\n\0, numInst"
    )
    prop _instAllocDesc :: (
	"%8t /* %0s buffer */\n .%0s$buf: align = 0x%1x {}\0, _objAlign"
    )
     
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop _memSeg :: LOG.OBJMEMSEG
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
     
    prop _objAlign :: GBL.DSPTYPE == 55 
               ? .buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)*2  
                : .buflen * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)  
    prop _objMemSeg :: .bufseg
    prop LogType :: .iType
    prop LogFormat :: .iFormat
    prop pageString :: (
        GBL.DSPTYPE == 62
	? ""
        : (GBL.DSPTYPE == 55 || GBL.DSPTYPE == 28)
	    ? (LOG.OBJMEMSEG.space() == "code"
	        ? " PAGE 0"
		: LOG.OBJMEMSEG.space() == "data"
		    ? " PAGE 1"
		    : LOG.OBJMEMSEG.space() == "io"
			? " PAGE 2"
			: " PAGE 0"
	      )
	    : " PAGE 1"
    )
    prop numInst :: (
    	LOG.gNumOf
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "log.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far LOG_Obj %0r;\n\0"
	}
	else {
	    "extern LOG_Obj %0r;\n\0"
	}
    )
    prop dataSize :: (
	$d = 0,
	scan ($i; LOG) {
	    if ($i.IsConfObj()) {
		$d += $i.buflen
	    },
	    $d += .objectSize()	 
	},
	$d
    )
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ENABLED :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Compile in logging"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst bufseg ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "bufseg"
	prop JSName :: "bufSeg"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst buflen :: 64 {
	
 
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "0,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
	prop Label :: "buflen (words)"
	prop JSName :: "bufLen"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop Set :: (
	    GlobalStatus.gDirty = 1,
	    .buflen = $1,
	    "ok"
	)
    }
    inst logtype :: "circular" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "circular,fixed"
	prop Label :: "logtype"
	prop JSName :: "logType"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst iType :: "printf" {
	prop Label :: "datatype"
	prop JSName :: "dataType"
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "printf,raw data"
	prop Visible :: 1
	prop Writable :: .iType == "system" ? 0 : 1
	prop NoGen :: 0
    }
    inst iFormat :: "0x%x, 0x%x, 0x%x" {
	prop Label :: "format"
	prop JSName :: "format"
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .iType == "raw data" ? 1 : 0
	prop NoGen :: 0
    }
}
object LOG_system :: LOG {
    param iComment :: "This object is required by the system to accumulate execution trace information"
    param iId :: 0
    param iIsUsed :: 1			 
    param iType :: "system"
    param iDelUser :: "LOG"
    param iDelMsg :: (
	"LOG_system is a system log and cannot be deleted."
    )
}
 
type PIP {
    isa  ObjectMgr
    prop Label :: "PIP - Buffered Pipe Manager"
    prop IsContainedIn :: IOF
    prop GlobalIcon :: 117
    prop InstanceIcon :: 118
    prop GlobalHelpTopic :: (
	109
    )
    prop InstanceHelpTopic :: (
	209
    )
    prop name :: "PIP"
    prop maxObjs :: (
	32767				 
    )
    prop objectSize :: (
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
	    $a = (27 * 1)
	},
	if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
	    $a = (34 * 1)
	},
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
	    $a = (30 * 1)
	},
	if (GBL.DSPTYPE == 28 ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") ||
	   (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE")) {
	    $a = (50 * 1)
	},
	if (GBL.DSPTYPE == 62) {
	    $a = (25 * 1)
	},
	$a
    )
    prop dataSize :: (
	$b = 0,
	scan ($i; PIP) {
	    if ($i.IsConfObj()) {
		$b += ((6) + $i.framesize) * $i.numframes + .objectSize()
	    }
	},
	$b
    )
    prop InstancePropertyPage :: (
	    "{B7240DF0-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    
    prop GlobalPropertyPage :: (
	    "{B7240DF1-AA51-11cf-9BFE-0000C0AC14C8}"
    )
    prop localCreate :: (
	"ok"
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: RUN_START(%1U_A_TABBEG), RUN_START(_%1U_A_TABBEG), RUN_END(%1U_A_TABEND), RUN_END(_%1U_A_TABEND) {%8t\n }\0, name"
    )
    prop AllocInst :: (
	"1\0, _instAllocDesc, _objMemSeg, _placement"
    )
    prop GenLinkEpilogue :: (
        "%0tPIP_A_TABLEN = %1d;\n\0, numInst"
    )
    prop _instAllocDesc :: (
	.bufalign > 0 ? "%8t /* %0s buffer */\n .pip%1d: align = 0x%2x {}\0, _objId, _objAlign" : "%8t /* %0s buffer */\n .pip%1d: {}\0, _objId"
    )
    prop _placement :: (0x7fffff / 2)
    prop _objId :: .iId
    prop _objAlign :: .bufalign
    prop _objMemSeg :: .bufseg
    prop _linkString :: (.gNumOf + .gNumEmbed) > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: PIP.OBJMEMSEG
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
     
    prop numInst :: (
        HST.gNumOf + PIP.gNumOf
    )
    prop mkId :: (
	.iId = .gNextId++,
	.gNumOf++,
	.iId
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "pip.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far PIP_Obj %0r;\n\0"
	}
	else {
	    "extern PIP_Obj %0r;\n\0"
	}
    )
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global gNumEmbed :: 0 {	 
	prop NoGen :: 0
    }
    global gNextId :: 0
    global OBJSIZE ::= ._objSize
    inst bufseg ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "bufSeg"
	prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 1
    }
    inst bufalign :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "bufAlign"
	prop Style :: 0x01 | 0x02
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if ($1 == 0) {
		$e = .error("Cannot set align value to 0")
	    }
	    else {
		.bufalign = $1
	    },
	    $e
	)
    }
    inst buf :: "<NULL>" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst framesize :: 8 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "framesize (words)"
	prop JSName :: "frameSize"
	prop Style :: GBL.DSPTYPE == 62 ? 0x02 : 0x01 |0x02
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("framesize must be >= 1.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.framesize = $1,
		"ok"
	    }
	)
    }
    inst numframes  :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop JSName :: "numFrames"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop Set :: (
	    if ($1 < 1) {
		.error("Pipes must contain at least 1 frame.")
	    }
	    else {
		GlobalStatus.gDirty = 1,
		.numframes = $1,
		"ok"
	    }
	)
    }
    inst monitor :: "reader" {
    	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "monitor"
	prop Enum :: "reader,writer,none"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    inst notifyWriter :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nwarg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterArg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nwarg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyWriterArg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst notifyReader :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderFxn"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nrarg0 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderArg0"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    inst nrarg1 :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName :: "notifyReaderArg1"
	prop Visible :: 1
	prop Writable :: (.iDelUser == "USER" ? 1 : 0)
	prop NoGen :: 0
	prop TabName :: "Notify Functions"
    }
    
    inst bufFrameAlign ::= ._objAlign  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
 
type SEM {
    isa ObjectMgr
    prop name :: "SEM"
    prop Label :: "SEM - Semaphore Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 137
    prop InstanceIcon :: 138
    prop GlobalHelpTopic :: (
	310
    )
    prop InstanceHelpTopic :: (
	410
    )
    prop InstancePropertyPage :: (
	"{D01ACC04-38DD-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{D01ACC05-38DD-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .sem: {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (8 + 3)
	},
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (10 + 4)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (8 + 3)
        },
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (16 + 6)
        },
	if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (16 + 6)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (10 + 4)
        },
	if (GBL.DSPTYPE == 28) {
            $a = (16 + 6)
        },
        $a
   )
    prop dataSize :: (
	SEM.objectSize * SEM.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "sem.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far SEM_Obj %0r;\n\0"
	}
	else {
	    "extern SEM_Obj %0r;\n\0"
        }
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iCount :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Initial semaphore count"
	prop JSName :: "count"
	prop Visible :: 1
	prop Writable :: 1
    }
}
 
 
type MBX {
    isa ObjectMgr
    prop name :: "MBX"
    prop Label :: "MBX - Mailbox Manager"
    prop IsContainedIn :: SYN 
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (
	307
    )
    prop InstanceHelpTopic :: (
	407
    )
    prop InstancePropertyPage :: (
	"{0EB45D44-38C1-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{0EB45D45-38C1-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0,	_bssAllocDesc, _memSeg, _placement"
	    }
    )
    prop _bssAllocDesc :: (
	    "%8t .mbx: {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop AllocInst :: (
	"1\0 _instAllocDesc, _instMemSeg, _placement"
    )
    prop _instAllocDesc :: (
	"%8t .%0s$que: align = 0x4 {%12t\n %0s$queElems = .;\n . += %1d;%8t\n }\0, _qElemSize"
    )
    prop _instMemSeg :: .iMbxSeg
    prop _qElemSize :: (
	if ((GBL.DSPTYPE == 55) && (GBL.DSPSUBTYPE != 5599)) {
             
            $a = .iMsgSize,
            if ($a & 0x1) {
                $a += 1
            },
	     
	     (4 + $a) * .iMbxLength  * 2 
	}
	else {
	    if (GBL.DSPTYPE == 28) {
                 
                $a = .iMsgSize,
                if ($a & 0x1) {
                    $a += 1
                },
	        (4 + $a) * .iMbxLength
	    }
	    else {
                 
                $a = .iMsgSize,
		$b = GBL.DSPWORDSIZE / GBL.DSPCHARSIZE,
		$c = $a & ($b - 1),
		if ($c != 0) {
		    $a = $a + ($b - $c)
		},
	        (4 + $a) * .iMbxLength
	    }
	}
    )
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (29)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (28)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (24)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (46)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (46)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (28)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (46)
        },
        $a
    )
    prop dataSize :: (
	$d = 0,
	scan ($i; MBX) {
	    $d += (GBL . DSPWORDSIZE / GBL . DSPCHARSIZE) * (($i.iMsgSize + 2) * $i.iMbxLength + .objectSize())
	},
	$d
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "mbx.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far MBX_Obj %0r;\n\0"
	}
	else {
	    "extern MBX_Obj %0r;\n\0"
	}
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst iMsgSize :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Message Size"
	prop JSName :: "messageSize"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1  == 0) {
		.error ("Message size cannot be zero")
	    }
	    else {
	    	GlobalStatus.gDirty = 1,
		.iMsgSize = $1,
		"ok"
	    }
	)
    }
    inst iMbxLength :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Mailbox Length"
	prop JSName :: "length"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    if ($1  == 0) {
		.error ("Mailbox length cannot be zero")
	    }
	    else {
	    	GlobalStatus.gDirty = 1,
		.iMbxLength = $1,
		"ok"
	    }
	)
    }
    inst iMbxSeg :: MBX.OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Element memory segment"
	prop JSName :: "elementSeg"
	prop Visible :: 1
	prop Writable :: 1
    }
}
 
type QUE {
    isa ObjectMgr
    prop name :: "QUE"
    prop Label :: "QUE - Atomic Queue Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 133
    prop InstanceIcon :: 134
    prop IsConfMod :: 1		 
    prop GlobalHelpTopic :: (
	309
    )
    prop InstanceHelpTopic :: (
	409
    )
    prop InstancePropertyPage :: (
	"{D01ACC01-38DD-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{D01ACC02-38DD-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .que: {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (2)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (2)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (2)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (4)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (4)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (2)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (4)
        },
        $a
    )
    prop dataSize :: (
	QUE.objectSize * QUE.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "que.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far QUE_Obj %0r;\n\0"
	}
	else {
	    "extern QUE_Obj %0r;\n\0"
	}
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
}
 
type LCK {
    isa ObjectMgr
    prop name :: "LCK"
    prop Label :: "LCK - Resource Lock Manager"
    prop IsContainedIn :: SYN
    prop GlobalIcon :: 129
    prop InstanceIcon :: 130
    prop IsConfMod :: 1		 
    prop GlobalHelpTopic :: (
	306
    )
    prop InstanceHelpTopic :: (
	406
    )
    prop InstancePropertyPage :: (
	"{0EB45D40-38C1-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{0EB45D41-38C1-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _bssAllocDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
	"%8t .lck: {}"
    )
    prop _objAllocDesc :: (
	"%8t .LCK$obj: {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (10)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (12)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (10)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (20)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (20)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (12)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (20)
        },
        $a
    )
    prop dataSize :: (
	LCK.objectSize * LCK.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "lck.h" : ""
    
 
    prop cGenHInst :: (
	if (GBL.DSPTYPE == 62) {
	    "extern far LCK_Obj %0r;\n\0"
	}
	else {
	    "extern LCK_Obj %0r;\n\0"
	}
    )
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
}
 
 
type STS {
    isa  ObjectMgr
    prop name :: "STS"
    prop Label :: "STS - Statistics Object Manager"
    prop IsContainedIn :: INS
    prop GlobalIcon :: 125
    prop InstanceIcon :: 126
    prop InstanceHelpTopic :: (
	212
    )
    
    prop GlobalHelpTopic :: (
	112
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _placement"
    )
    prop _globalAllocDesc :: (
	"%8t .%1L: RUN_START(%1U_A_TABBEG), RUN_START(_%1U_A_TABBEG), RUN_END(%1U_A_TABEND), RUN_END(_%1U_A_TABEND) {%8t\n }\0, name"
    )
    prop localInit :: (
	if (PRD.CALLBACKOBJ != nil) {
	    .error("STS initialization failure")
	},
	PRD.CALLBACKOBJ = STS
    )
    prop objectSize :: (
	(4 * 2)
    )
    prop _placement :: (0x7fffff / 2)
    prop _linkString :: .gNumOf > 0 ? "*(.%1L)" : "/* no %1U objects */"
    prop _memSeg :: STS.OBJMEMSEG
     
    prop _objSize :: GBL.DSPTYPE == 55 ? (2 * .objectSize()) : .objectSize()
    prop dataSize :: (
	.objectSize() * (STS.gNumOf + STS.gNumEmbed)
    )
    prop maxObjs :: (
	32767			 
    )
    prop InstancePropertyPage :: (
	"{B7240DEE-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
    prop GlobalPropertyPage :: (
	"{B7240DEF-AA51-11cf-9BFE-0000C0AC14C7}"
    )
    
 
    prop STSGetMaxFmt :: (
	.format
    )
    prop STSGetSumFmt :: (
	.format
    )
    prop STSGetAvgFmt :: (
	"%.2f"
    )
    prop STSFilterSum :: (
	(.iA * $1 + .iB * $2) / (1.0 * .iC)
    )
    prop STSFilterMax :: (
	(.iA * $1 + .iB) / (1.0 * .iC)
    )
    prop HighTimeBased :: (
	.unittype == "High resolution time based" ? 1 : 0
    )
    prop LowTimeBased :: (
	.unittype == "Low resolution time based" ? 1 : 0
    )
     
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "sts.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far STS_Obj %0r;\n\0"
	}
	else {
	    "extern STS_Obj %0r;\n\0"
        }
    )
    prop modifiable :: (
	((.iDelUser == "USER" || .iDelUser == "HWI") ? 1 : 0)
    )
    prop untype :: (
        if (.unittype == "Not time based") {
	    $a = 2
	},
	if (.unittype == "High resolution time based") {
	    $a = 0
        },
	if (.unittype == "Low resolution time based") {
	    $a = 1
        },
	$a
    )
    prop optype :: (
        if (.operation == "Nothing") {
	    $a = 0
	},
	if (.operation == "A * x") {
	    $a = 1
        },
	if (.operation == "A * x + B") {
	    $a = 2
        },
	if (.operation == "(A * x + B) / C") {
	    $a = 3
        },
	$a
    )
    
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global gNumEmbed :: 0 {	 
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst prev :: 0 {		 
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop JSName :: "previousVal"
	prop NoGen :: GBL.DSPTYPE != 40 && GBL.DSPTYPE != 62
	prop Set :: (
	    .prev = $1,
	    .prevlow = $1 & 0xffff,
	    .prevhigh = ($1 >> 16) & 0xffff,
	    "ok"
	)
    }
    
 
    inst format :: "%g" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "format"
	prop NoGen :: 1
    }
    
 
    inst filter :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "filter"
	prop NoGen :: 0
    }
    
 
    inst maxformat :: "%g" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "maxformat"
	prop NoGen :: 0
    }
    inst sumformat :: "%g" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "sumformat"
	prop NoGen :: 0
    }
    inst avgformat :: "%.2f" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop Label :: "avgformat"
	prop NoGen :: 0
    }
    
 
    inst unittype :: "Not time based" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Not time based,High resolution time based,Low resolution time based"
	prop Label :: "unit type"
	prop JSName :: "unitType"
	prop Visible :: 1
	prop Writable :: .modifiable()
	prop NoGen :: 1
	prop Set :: (
	    .unittype = $1,
	    if ($1 == "High resolution time based") {
		.iA = 1,
		.iB = 0,
		.iC = 1,
		.operation = "A * x"
	    }
	    else {
		if ($1 == "Low resolution time based") {
		    .iA = 1,
		    .iB = 0,
		    .iC = 1,
		    .operation = "A * x"
		}
		else {
		    .iA = 1,
		    .iB = 0,
		    .iC = 1,
		    .operation = "Nothing"
		}
	    },
	    "ok"
	)
    }
    inst operation :: "Nothing" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Nothing,A * x,A * x + B,(A * x + B) / C"
	prop Label :: "host operation"
	prop JSName :: "operation"
	prop Visible :: 1
	prop Writable :: (
	    (.unittype != "Low resolution time based") && .modifiable()
	)
	prop NoGen :: 1
	prop Set :: (
	    .operation = $1,
	    if ($1 == "Nothing" && .unittype != "High resolution time based") {
		.iA = 1,
		.iB = 0,
		.iC = 1
	    }
	    else {
		if ($1 == "A * x") {
		    .iB = 0,
		    .iC = 1
		}
		else {
		    if ($1 == "A * x + B") {
			.iC = 1
		    }
		}
	    },
	    "ok"
	)
    }
    inst op ::= .optype() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
     }
    inst uType ::= .untype() {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 0
     }
    inst iA :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    !(.unittype != "Not time based" || .operation == "Nothing")
	)
	prop Label :: "A"
	prop JSName :: "numA"
	prop NoGen :: 0
    }
    inst iB :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    !(.unittype == "Low resolution time based" || .operation == "Nothing" || .operation == "A * x")
	)
	prop Label :: "B"
	prop JSName :: "numB"
	prop NoGen :: 0
    }
    inst iC :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 1
	prop Writable :: (.modifiable() &&
	    (.unittype == "Not time based" && .operation == "(A * x + B) / C")
	)
	prop Label :: "C"
	prop JSName :: "numC"
	prop NoGen :: 0
    }
    inst prevhigh :: 0 {	 
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: GBL.DSPTYPE == 40 || GBL.DSPTYPE == 62
    }
    
 
    inst prevlow :: 0 {		 
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
}
 
type SYS {
    isa Module
    prop name :: "SYS"
    prop Label :: "SYS - System Settings"
    prop IsContainedIn :: SYSTEM
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop IsConfMod :: 1		 
    prop GlobalHelpTopic :: (
	313
    )
    prop InstanceHelpTopic :: (
	413
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop AllocType :: ( .PUTCFXN == @_UTL_doPutc ?
	"2\0, _globalAllocDesc,	_memSeg, _midPlace, 	      _traceString, _traceSeg, _midPlace"
	:
	"1\0, _globalAllocDesc,	_memSeg, _midPlace"
    )
    prop _globalAllocDesc :: (
	"%8t .sys:     {}"
    )
    prop _traceString   :: (
	"%8t .trace: fill = 0x0 {%12t\n_SYS_PUTCBEG = .;\n. += 0x%1x;\n_SYS_PUTCEND = . - 1;%8t\n }\0, _traceSize"
    )
    prop _midPlace :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _traceSeg :: SYS.TRACESEG
    prop _traceSize :: SYS.TRACESIZE
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global TRACESIZE :: 512 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Format :: "%d"
	prop Style :: 0x01 | 0x02
	prop Label :: "Trace Buffer Size"
	prop JSName :: "TRACESIZE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global TRACESEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1) 
	prop Label :: "Trace Buffer Memory"
	prop JSName :: "TRACESEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global ABORTFXN :: @_UTL_doAbort {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Abort Function"
	prop JSName :: "ABORTFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global ERRORFXN :: @_UTL_doError {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Error Function"
	prop JSName :: "ERRORFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global EXITFXN :: @_UTL_halt {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit Function"
	prop JSName :: "EXITFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global PUTCFXN :: @_UTL_doPutc {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Putc Function"
	prop JSName :: "PUTCFXN"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
 
type SIO {
    isa ObjectMgr
    prop name :: "SIO"
    prop Label :: "SIO - Stream Input and Output Manager"
    prop IsContainedIn :: IOF
    prop DependsOn :: "DIO,DGN,DHL,DPI"
    prop GlobalIcon :: 139
    prop InstanceIcon :: 140
    prop GlobalHelpTopic :: (
	311
    )
    prop InstanceHelpTopic :: (
	411
    )
    prop InstancePropertyPage :: (
	"{7C4C9A60-763E-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7C4C9A61-763E-11d1-988B-0020AFEE33C6}" 
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "2\0, _bssAllocDesc, _memSeg, _placement,
	          _objAllocDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
        "%8t .SIO$bss: {%12t\n *(.SIO$bss)%8t\n }"
    )
    prop _objAllocDesc :: (
        "%8t .SIO$obj: {%12t\n *(.SIO$obj)%8t\n }"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop AllocInst ::  (
	"1\0, _instBufDesc, _instBufSeg, _placement"
    )
    prop _instBufDesc :: (
	.iAlign > 1? "%8t .%0s$bufs: align = 0x%1x {}\0, _objAlign" : "%8t .%0s$bufs: {}"
    )
    prop _objAlign :: .iAlign
    prop _instBufSeg :: .iBufSegid
    prop defDev :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
	            if ($j == nil
		        && $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {
			
 
			$j = $i,
			break
		    }
		}
	    }
	},
	$j
    )
    prop devList :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
	            if ($j == nil
			&& $i.iIsTerminal != 0 && $i.iIsVirtual == 0) {
			
 
			$j = $i,
			scan ($a; DIO) {
			    if ($a == $i) {
				$i.numTimeUse++
			    }
			},
		        break
	            }
		}
	    }
	},
	$j
    )
     
    prop setDev :: (
	$h = nil,
	$i = nil,
	$j = nil,
	scan ($h; nil) {
	    if ($h.isDriver == 1) {
		scan ($i; $h) {
		    if ($i == $1) {
			$j = $i
		    }
		}
	    }
	},
	$j
    )
    prop localCanCreate :: (
	if (.defDev == nil) {
	    .error ("A driver device must be created before creating a stream.")
	}
	else {
	    "ok"
	}
    )
    prop localDelete :: (
	scan ($a; DIO) {
	    if ($a == .iDevice) {
		.iDevice.numTimeUse--
	    }
	},
	"ok"
    )
     
    prop cGen :: 1
    
 
    prop cHeaderName :: .gNumOf > 0 ? "sio.h" : ""
    
 
    prop cGenHInst :: (
        if (GBL.DSPTYPE == 62) {
	    "extern far SIO_Obj %0r;\n\0"
	}
	else {
	    "extern SIO_Obj %0r;\n\0"
        }
    )
    global gNumEmbed :: 0 {   
	prop NoGen :: 1
    }
    global OBJMEMSEG :: L0SARAM {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global USEISSUERECLAIM :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use Only Issue/Reclaim Model"
	prop JSName :: "USEISSUERECLAIM"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .USEISSUERECLAIM = $1,
	    if ($1 == 1) {
		scan ($i; SIO) {
		    $i.iModelName = "Issue/Reclaim"
		}
	    },
	    "ok"
	)
    }
    
    inst iDevice :: SIO.devList {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop TypeTest :: $1.isDriver == 1
	prop MemberTest :: $1.driverType != "DEV_IOMTYPE"
	prop Label :: "Device"
	prop JSName :: "deviceName"
	prop Set :: (
	    if (($1.iIsTerminal == 0) && (.iDevCtrlParam == "")) {
		    .error("To select a stacking device, enter first a terminal device in Device Control String")
	    }
	    else {
		if ($1.iIsVirtual == 1) {
		    .error("The device you have selected is a virtual instance, you must select a non-virtual device")
		}
		else {
		    scan($a; DIO) {
			if ($a == .iDevice) {
			    .iDevice.numTimeUse--
			}
		    },
		    scan($b; DIO) {
			if ($b == $1) {
			    $1.numTimeUse++
			}
		    },
		    .iDevice = .setDev($1),
		    "ok"
		}
	    }
	)
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iDevCtrlParam :: "" {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Device Control String"
	prop JSName :: "controlParameter"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iDevId ::= .iDevice.iDevId
    inst iFxns  ::= .iDevice.iFxns
    inst iMode :: "input" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "input,output"
	prop Label :: "Mode"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iBufsize :: 0x80 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x02
	prop Label :: "Buffer size"
	prop JSName :: "bufSize"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iNbufs :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Style :: 0x01
	prop Label :: "Number of buffers"
	prop JSName :: "numBufs"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iBufSegid ::= .OBJMEMSEG {
	prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: MEM
	prop MemberTest :: MEM.dataMember($1)
	prop Label :: "Place buffers in memory segment"
	prop JSName :: "bufSegId"
	prop Visible :: 1
	prop Writable :: .iAllocBuf == 1
    }
    inst iAlign :: 1 {
	prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768"
	prop Label :: "Buffer alignment"
	prop JSName :: "bufAlign"
	prop Visible :: 1
	prop Writable :: .iAllocBuf == 1
    }
    
 
    inst iFlush :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Flush"
	prop JSName :: "flush"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst iModelName :: "Standard" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "Standard,Issue/Reclaim"
	prop Label :: "Model"
	prop JSName :: "modelName"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $e = "ok",
	    if (.USEISSUERECLAIM == 1) {
		if ($1 == "Standard") {
	    	    $e = .error("SIO Issue/Reclaim model support selected")
	        }
	        else {
		    .iModel = $1 == "Standard"
			? "SIO_STANDARD"
			: "SIO_ISSUERECLAIM",
	            .iModelName = $1
	        }
	    }
	    else {
		.iModel = $1 == "Standard"
		    ? "SIO_STANDARD"
		    : "SIO_ISSUERECLAIM",
	        .iModelName = $1
	    },
	    $e
	)
    }
    inst iAllocBuf ::= .iSaveAllocBuf {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Allocate Static Buffer(s)"
	prop JSName :: "allocStaticBuf"
	prop Visible :: 1
	prop Writable :: 1
	prop Set :: (
	    .iSaveAllocBuf = $1,
	    "ok"
	)
    }
    inst iSaveAllocBuf :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iModel :: "SIO_STANDARD" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "SIO_STANDARD,SIO_ISSUERECLAIM"
	prop Visible :: 0
	prop Writable :: 0
    }
    inst iTimeout ::= .iModel == "SIO_ISSUERECLAIM" ? .iSaveTimeout : -1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Timeout for I/O operation"
	prop JSName :: "timeout"
	prop Visible :: 1
	prop Writable :: .iModel == "SIO_ISSUERECLAIM"
	prop Set :: (
	    .iSaveTimeout = $1,
	    "ok"
	)
    }
    inst iSaveTimeout :: -1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
    inst useCallBackFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "use callback function"
	prop JSName :: "useCallBackFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst callBackFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "callback function"
	prop JSName :: "callBackFxn"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst arg0 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "argument 0"
	prop JSName :: "arg0"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
    inst arg1 :: 0 {
	prop Type :: "{E91790E0-0456-11d2-B8D0-006008BDB66F}"
	prop Label :: "argument 1"
	prop JSName :: "arg1"
	prop Visible :: 1
	prop Writable :: .useCallBackFxn
	prop NoGen :: 0
	prop TabName :: "Callback"
    }
}
 
type GIO {
    isa Module
    prop Visible :: 1
    prop name :: "GIO"
    prop Label :: "GIO - General Input/Output Manager"
    prop IsConfMod :: .USEGIO 
    prop IsContainedIn :: IOF
    prop DependsOn :: "UDEV"
 
    prop GlobalIcon :: 141
    prop InstanceIcon :: 142
    prop GlobalHelpTopic :: (
	320
    )
    prop InstanceHelpTopic :: (
	420
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop AllocType :: (
	"1\0, _globalAllocDesc, _memSeg, _midPlace"
    )
    prop _globalAllocDesc :: (
	"%8t .gio:     {}"
    )
    prop _midPlace :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    
 
    global CALLBACKOBJ :: nil {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    global USEGIO :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable General Input/Output Manager"
	prop JSName :: "ENABLEGIO"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
 
    global CREATEFXN ::= .USEGIO == 1 ? @_SEM_create : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create Function"
	prop JSName :: "CREATEFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global DELETEFXN ::= .USEGIO == 1 ? @_SEM_delete : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete Function"
	prop JSName :: "DELETEFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global PENDFXN ::= .USEGIO == 1 ? @_SEM_pend : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Pend Function"
	prop JSName :: "PENDFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
    global POSTFXN ::= .USEGIO == 1 ? @_SEM_post : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Post Function"
	prop JSName :: "POSTFXN"
	prop Visible :: 1
	prop Writable :: .USEGIO
	prop NoGen :: 0
    }
}
 
type DEV {
    isa ObjectMgr
    prop name :: "DEV"
    prop Visible :: 0
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _bssAllocDesc, _memSeg, _placement"
	},
	
 
	if (.devCount() > 0 ) {
	    "1\0, _devtableDesc, _memSeg, _placement"
	}
    )
    prop _bssAllocDesc :: (
	"%8t .dev: {}"
    )
    prop _devtableDesc :: (
	"%8t .devtable: {}"
    )
    prop _memSeg :: MEM.CFGOBJSEG
    prop _placement :: (0x7fffff / 2)
    prop DependsOn :: "PIE"
    prop devCount :: (
	$i = nil,
	$a = 0,
	scan ($i; nil) {
	    if ($i.isDriver == 1) {
		$a = $a + $i.gNumOf
	    }
	},
	$a
    )
}
 
type UDEV {
    isa ObjectMgr
    prop name :: "UDEV"
    prop Label :: "User-Defined Devices"
    prop IsContainedIn :: SIODRIVER
    prop DependsOn :: "DEV"
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	315
    )
    prop InstanceHelpTopic :: (
	415
    )
    prop InstancePropertyPage :: (
	"{7AE86AA0-35C0-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7AE86AA1-35C0-11d1-988B-0020AFEE33C6}"
    )
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .udev: {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    prop _driverType :: (
	.fxnTableType == "DEV_Fxns" ? "DEV_SIOTYPE" : "DEV_IOMTYPE"
    )
    inst iInit :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop Label :: "init function"
	prop JSName :: "initFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .iInit = $1,
	    .initFxn = .iInit,
	    "ok"
	)
    }
    inst iFxns :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop Label    :: "function table ptr"
	prop JSName :: "fxnTable"
	prop Visible  :: 1
	prop Writable :: 1
    }
    
    inst fxnTableType :: "DEV_Fxns" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "DEV_Fxns,IOM_Fxns"
	prop Label :: "function table type"
	prop JSName :: "fxnTableType"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst driverType ::= ._driverType {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: "DEV_SIOTYPE,DEV_IOMTYPE"
	prop Visible :: 0
    }
    
    inst iDevId :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "device id"
	prop JSName :: "deviceId"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    .iDevId = $1,
	    .deviceId = .iDevId,
	    "ok"
	)
    }
    inst iParams :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label    :: "device params ptr"
	prop JSName :: "params"
	prop Visible  :: 1
	prop Writable :: 1
    }
    inst deviceId :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop JSName   :: ""
	prop Visible  :: 0
    }
    inst initFxn :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"	
	prop JSName   :: ""
	prop Visible  :: 0
    }
    inst iIsStacking ::0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Stacking Device"
	prop JSName :: "stackingDevice"
	prop Visible :: 0
	prop Writable :: 1
	prop NoGen :: 1
    }
    inst deviceGlobalDataPtr :: 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "device global data ptr"
	prop JSName :: "deviceGlobalDataPtr"
	prop Visible :: 1
	prop Writable :: .fxnTableType == "IOM_Fxns"
    }
    inst iIsTerminal ::= .fxnTableType == "DEV_Fxns" ? 1 : 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}
 
type DIO {
    isa ObjectMgr
    prop Visible :: 1
    prop Label :: "DIO - Class Driver"
    prop name :: "DIO"
    prop IsContainedIn :: SIODRIVER
    prop DependsOn :: "UDEV"
    prop GlobalIcon :: 127
    prop InstanceIcon :: 127
    prop GlobalHelpTopic :: (
	319
    )
    prop InstanceHelpTopic :: (
	419	
    )
    prop InstancePropertyPage :: (		
	"{f80273c0-3838-11d2-a32c-006097656921}"
    )
    
    prop GlobalPropertyPage :: (		
	"{050a0600-3839-11d2-a32c-006097656921}"
    )
    prop maxObjs :: (32767)
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
	"%8t .dio: {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: .OBJMEMSEG
    prop isDriver :: (
	1
    )
    prop mdObject :: (
	$h = nil,
	$j = nil,
	scan ($h; UDEV) {
	    if ($h.driverType == "DEV_IOMTYPE" ) {
		$j = $h,
                break
	    }
	},
	$j
    )
    prop localCanCreate :: (
	if (.mdObject == nil) {
	    .error ("An IOM type device must be created first.")
	}
	else {
	    "ok"
	}
    )
    prop numTsk :: (
	$a = 0,
	$h = nil,
	scan ($h; DIO) {
	    if ($h.useCallBackFxn == 0) {
		$a = $a + $h.numTimeUse
	    }
	},
	$a
    )
    prop numSwi :: (
	$a = 0,
	$h = nil,
	scan ($h; DIO) {
	    if ($h.useCallBackFxn == 1) {
		$a = $a + $h.numTimeUse
	    }
	},
	$a
    )
	
    prop functionTablePtr :: (
	if (.STATIC) {
	    if (.useCallBackFxn) {
		@_DIO_cbStaticFxns
	    }
	    else {
		@_DIO_tskStaticFxns
	    }
	}
	else {
	    if (.useCallBackFxn) {
		@_DIO_cbDynamicFxns
	    }
	    else {
		@_DIO_tskDynamicFxns
	    }
	}
    )
    global OBJMEMSEG :: L0SARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    global STATIC :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Create all DIO Objects Statically"
	prop JSName :: "STATICCREATE"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
    global NUMTSKBASE ::= .numTsk  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "TSK based"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    global NUMSWIBASE ::= .numSwi  {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "SWI based"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst useCallBackFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "use callback version of DIO function table (for SWI)"
	prop JSName :: "useCallBackFxn"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
    }
    
    inst fxnsTable ::= .functionTablePtr {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst initFxn :: @_DIO_init {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst deviceName :: .mdObject {
        prop Type     :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop MemberType :: UDEV
	prop MemberTest :: $1.driverType == "DEV_IOMTYPE"
        prop Label    :: "device name"
        prop JSName   :: "deviceName"
        prop Visible  :: 1
        prop Writable :: 1
	prop NoGen :: 0
    }
    inst chanParams :: 0 {
        prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
        prop Label    :: "channel parameters"
        prop JSName   :: "chanParams"
        prop Visible  :: 1
        prop Writable :: 1
	prop NoGen :: 0
    }
    inst numTimeUse :: 0 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDevId :: 0 {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iFxns ::= .functionTablePtr {
	prop Type     :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Visible  :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iIsTerminal :: 1 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
}
 
type DGN {
    isa ObjectMgr
    prop name :: "DGN"
    prop Label :: "DGN - Software Generator Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	302
    )
    prop InstanceHelpTopic :: (
	402
    )
    prop InstancePropertyPage :: (
	"{054FE166-B014-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{054FE167-B014-11d0-9885-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: (
        "%8t .dgn: {}"
    )
    prop _placement :: (0x7fffff / 2)
    prop _memSeg :: MEM.CFGOBJSEG
    inst iDevice :: "user" {
	prop Type :: "{21455EA1-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Enum :: GBL.DSPARITHMETIC == "FLOAT" ?
		"user,sine,random,constant,printFloat,printHex,printInt"
		:"user,sine,random,constant,printHex,printInt"
	prop Label :: "Device category"
	prop JSName :: "device"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 1
	prop Set :: (
	    $a = $1,
	    if ($a != .iDevice) {
		.iDevice = $a,
		.iUserFxn = @_FXN_F_nop	 
	    },
	    if ($a == "user") {
		.iUserFxn = .iSaveUserFxn
	    },
	    if ($a == "printFloat") {
		.iUserFxn = @_DGN_printFloat
	    },
	    if ($a == "printHex") {
		.iUserFxn = @_DGN_printHex
	    },
	    if ($a == "printInt") {
		.iUserFxn = @_DGN_printInt
	    },
	    "ok"
	)
    }
    inst iUseDefaults :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Use default parameters"
	prop Visible :: 1
	prop JSName :: "useDefaultParam"
	prop Writable :: .iDevice == "sine" || .iDevice == "constant" || .iDevice == "random" || .iDevice == "user"
    }
    inst iDevId ::= .iDevice == "constant" ? @DGN_CONST : .iDevice == "random" ? @DGN_RAND : .iDevice == "sine" ? @DGN_SINE : @DGN_USER {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Device ID"
	prop JSName :: "deviceId"
	prop Visible :: 1
	prop Writable :: 0
    }
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    
 
    inst iConstant :: GBL.DSPARITHMETIC == "FIXED" ? 1 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label  :: "Constant value"
	prop JSName :: "constant"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "constant" || .iDevice == "user")
    }
    inst iRandSeed :: 1 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Seed value"
	prop JSName :: "seedValue"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iRandLower :: GBL.DSPARITHMETIC == "FIXED" ? -32767 : 0.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Lower limit"
	prop JSName :: "lowerLimit"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iRandUpper :: GBL.DSPARITHMETIC == "FIXED" ? 32767 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Upper limit"
	prop JSName :: "upperLimit"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "random" || .iDevice == "user")
    }
    inst iSineGain :: GBL.DSPARITHMETIC == "FIXED" ? 32767 : 1.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Gain"
	prop JSName :: "gain"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSineFreq :: GBL.DSPARITHMETIC == "FIXED" ? 1 : 1000.0 {
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Frequency (Hz)"
	prop JSName :: "frequency"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSinePhase :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0.0{
	prop Type :: "{3EE4CB80-E273-11d0-BB8F-0000C008F2E9}"
	prop Style  :: GBL.DSPARITHMETIC == "FIXED" ? 0 : 0x04 
	prop Format :: GBL.DSPARITHMETIC == "FIXED" ? "%d" : "%f"
	prop Label :: "Phase (radians)"
	prop JSName :: "phase"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iSineRate :: GBL.DSPARITHMETIC == "FIXED" ? 256 : 44000 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Sample rate (samples/sec)"
	prop JSName :: "rate"
	prop Visible :: 1
	prop Writable :: .iUseDefaults == 0 && (.iDevice == "sine" || .iDevice == "user")
    }
    inst iUserFxn :: .iDevice == "printFloat" ? @_DGN_printFloat : .iDevice == "printHex" ? @_DGN_printHex : .iDevice == "printInt" ? @_DGN_printInt : @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "User function"
	prop JSName :: "fxn"
	prop Visible :: 1
	prop Writable :: .iDevice == "user"
	
 
	prop Set :: (
	    .iUserFxn = $1,
	    .iSaveUserFxn = .iUserFxn,
	    "ok"
	)
    }
    inst iSaveUserFxn :: @_FXN_F_nop {
	prop Visible :: 0
	prop Writable ::0
	prop NoGen :: 1
    }
    inst iUserArg ::= 0 {
	prop Type :: "{7C434D01-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "User function argument"
	prop JSName :: "arg"
	prop Visible :: 1
	prop Writable :: .iDevice == "user"
    }
    
 
    inst iFxns :: @_DGN_FXNS {
	prop NoGen :: 1
    }
}
 
type DHL {
    isa ObjectMgr
    prop name :: "DHL"
    prop Label :: "DHL - Host Link Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalHelpTopic :: (303)
    prop InstanceHelpTopic :: (403)
    prop InstancePropertyPage :: ("{9C29DA20-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalPropertyPage :: ("{9C29DA21-90F9-11d1-988B-0020AFEE33C6}")
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop DependsOn :: "DEV"
    prop Visible :: 1
    prop isDriver :: 1
    
 
    prop objectSize :: (
        if (GBL.DSPTYPE == 62) {
            $a = (19)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 1) {
            $a = (22)
        },
        if (GBL.DSPTYPE == 54 && GBL.FARMODE == 0) {
            $a = (19)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "LARGE") {
            $a = (34)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "HUGE") {
            $a = (34)
        },
        if (GBL.DSPTYPE == 55 && GBL.MEMORYMODEL == "SMALL") {
            $a = (22)
        },
        if (GBL.DSPTYPE == 28) {
            $a = (34)
        },
        $a
    )
    prop dataSize :: (
	DHL.objectSize * DHL.gNumOf * (GBL.DSPWORDSIZE / GBL.DSPCHARSIZE)
    )
    global gChannelsAvailable :: (
        $a = 0,
        scan ($i; HST) {
            if ($i.iDHLAvailable == 1) {
                $a++
            }
        },
        $a
    ) 
    prop localCanCreate :: (
        if (.gChannelsAvailable > 0) {
            "ok"
        }
	else {
	    .warning("No HST channels are available for a new DHL device.")
	}
    )
    prop localCreate :: (
        .gChannelsAvailable--,
	.seizeHSTChannel(.iHSTChannel),
        "ok"
    )
       
    prop seizeHSTChannel :: (
	$1.iDelUser = "DHL",
	$1.iDHLAvailable = 0,
	$1.notify = @_DHL_notify,
	$1.arg0 = $1.iId,
	"ok"
    )
    prop localDelete ::(
        .gChannelsAvailable++,
	.releaseHSTChannel(.iHSTChannel),
        "ok"
    )
    prop releaseHSTChannel :: (
	$1.iDelUser = "USER",
	$1.iDHLAvailable = 1,
	$1.notify = @_FXN_F_nop,
	$1.arg0 = 0,
	"ok"
    )
    prop AllocType :: (
	if (.gNumOf > 0) {
	    "1\0, _globalAllocDesc, _memSeg, _placement"
	}
    )
    prop _globalAllocDesc :: "%8t .dhl: {}"
    prop _memSeg :: .OBJMEMSEG
    prop _placement :: (0x7fffff / 2)
    global OBJMEMSEG :: L0SARAM {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
        prop MemberType :: MEM
        prop MemberTest :: MEM.dataMember($1)
        prop Label :: "Object Memory"
	prop JSName :: "OBJMEMSEG"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 1
    }
    inst iHSTChannel :: (
        scan ($i; HST) {
            if ($i.iDHLAvailable == 1) {
                $a = $i 
            }
        },
        $a
    ) {
        prop Type :: "{7BA2DA00-5A53-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Underlying HST Channel"
	prop JSName :: "hstChannel"
        prop MemberType :: HST
	prop MemberTest :: ((($1.iDHLAvailable == 1) || ($1 == .iHSTChannel)) ? 1 : 0)
        prop Set :: (
            if ($1.iDHLAvailable != 1) {
		 
                .error("This channel is already in use.")
            }
            else {
                .releaseHSTChannel(.iHSTChannel),
		.seizeHSTChannel($1),
                .iHSTChannel = $1,
                "ok"
            }
        )
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
    }
    inst iMode ::= .iHSTChannel.mode {
	prop Type :: "{21455EA3-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Mode"
	prop JSName :: "mode"
	prop Visible :: 1
	prop Writable :: 0
	prop NoGen :: 0
    }
    inst iDevId ::= (.iHSTChannel.iId) {
	prop NoGen :: 0
    }
    
 
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    inst iIsVirtual :: 0 {
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop NoGen :: 1
    }
    inst iFxns :: @_DHL_FXNS {
	prop NoGen :: 1
    }
}
 
type DPI {
    isa ObjectMgr
    prop name :: "DPI"
    prop Label :: "DPI - Pipe Driver"
    prop IsContainedIn :: SIODRIVER
    prop GlobalIcon :: 127
    prop InstanceIcon :: 128
    prop GlobalHelpTopic :: (
	304
    )
    prop InstanceHelpTopic :: (
	404
    )
    prop InstancePropertyPage :: (
	"{7FE06FA0-2DE9-11d1-988B-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{7FE06FA1-2DE9-11d1-988B-0020AFEE33C6}"
    )
    prop DependsOn :: "DEV"
    prop maxObjs :: (32767)
    prop isDriver :: (
	1
    )
    prop localCreate :: (
	.gCurDevId += 1,
	"ok"
    )
    global gCurDevId :: 0 {
	prop Visible :: 0
	prop Writable :: 0
	prop NoGen :: 1
    }
    inst iDevId :: DPI.gCurDevId {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop Writable :: 0
	prop Set :: (
	    .error("DPI.iDevId parameter no longer settable, it is now handled automatically")
	)
    }
    inst iIsVirtual :: 0 {
        prop Label :: "Allow virtual instances of this device."
	prop JSName :: "allowVirtual"
        prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 1
        prop Writable :: 1
        prop NoGen :: 0
	prop Set :: (
	    if ($1 == 1) {
		$a = "ok",
		$b = 1,
		scan ($i; SIO) {
		    if ($i.iDevice == self) {
			$a = .error("This DPI instance is being used by one or more SIO instances, cannot reconfigure"),
			$b = 0
		    }
		},
		if ($b == 1) {
		    .iIsVirtual = 1
		},
		$a
	    }
	    else {
		.iIsVirtual = 0,
		"ok"
	    }
	)
    }
    inst iIsTerminal :: 1 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop NoGen :: 1
    }
    
 
    inst iFxns :: @_DPI_FXNS {
	prop NoGen :: 1
    }
}
 
type MSGQ {
    isa Module
    prop Visible :: 1
    prop name :: "MSGQ"
    prop Label :: "MSGQ - Message Queue Manager"
    prop IsConfMod :: .USEMSGQ 
    prop IsContainedIn :: IOF
    prop DependsOn :: "GIO,SIO"
 
    prop GlobalIcon :: 131
    prop InstanceIcon :: 132
    prop GlobalHelpTopic :: (
	323
    )
    prop InstanceHelpTopic :: (
	423
    )
    prop InstancePropertyPage :: (
	"{473C4A62-B1A8-11d0-9885-0020AFEE33C6}"
    )
    
    prop GlobalPropertyPage :: (
	"{473C4A63-B1A8-11d0-9885-0020AFEE33C6}"
    )
    global USEMSGQ :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Enable MSGQ Manager"
	prop JSName :: "ENABLEMSGQ"
	prop Visible :: 1
	prop Writable :: 1
	prop NoGen :: 0
    }
}
 
type HOOK {
    isa ObjectMgr
    prop name :: "HOOK"
    prop Label :: "HOOK - Module Hook Manager"
    prop IsContainedIn :: SYSTEM
    prop DependsOn :: "SWI"
    prop InstancePropertyPage :: (
	"{473C4A64-B1A8-11d0-9885-0020AFEE33C6}"
    )
    prop GlobalIcon :: 181
    prop InstanceIcon :: 182
    prop GlobalHelpTopic :: (
	318
    )
    prop InstanceHelpTopic :: (
	418
    )
    prop localCreate :: (
	if (.gNumOf == 0) {
	    HOOK_KNL.iIsUsed = 1,
	    .mkId(0)
	},
	"ok"
    )
    
    prop localDelete :: (
	if (.gNumOf == 2) {
	    HOOK_KNL.iIsUsed = 0,
	    .rmId
	},
	"ok"
    )
    prop maxObjs :: (32767)	 
    
    prop SortByField :: "iPri"
    prop SortGroups :: 1
    global KNLID ::= (HOOK_KNL.Order - 1) {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
    }
    inst initFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Initialization function"
	prop JSName :: "initFxn"
	prop Visible :: 1
	prop Writable :: 1
    }
    inst createFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Create function"
	prop JSName :: "createFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst deleteFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Delete function"
	prop JSName :: "deleteFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst exitFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Exit function"
	prop JSName :: "exitFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst callSwitchFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call switch function"
	prop JSName :: "callSwitchFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst switchFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Switch function"
	prop JSName :: "switchFxn"
	prop Visible :: 1
	prop Writable :: .callSwitchFxn
    }
    inst callReadyFxn :: 0 {
	prop Type :: "{21455EA0-B96A-11cf-9BFE-0000C0AC14C7}"
	prop Label :: "Call ready function"
	prop JSName :: "callReadyFxn"
	prop Visible :: 1
	prop Writable :: .iDelUser == "USER"
    }
    inst readyFxn :: @_FXN_F_nop {
	prop Type :: "{7C434D00-1629-11d0-9BFE-0000C0AC14C7}"
	prop Label :: "Ready function"
	prop JSName :: "readyFxn"
	prop Visible :: 1
	prop Writable :: .callReadyFxn
    }
     
    inst Order :: 2 {
	prop Type :: "{21455EA2-B96A-11cf-9BFE-0000C0AC14C7}"
	prop JSName :: "order"
	prop NoGen :: 1
	prop Writable :: 1
    }
     
    inst iPri :: 0 {
        prop Type :: "{A11FE980-C07A-11cf-9BFE-0000C0AC14C7}"
        prop Visible :: 0
        prop NoGen :: 1
    }
}
object HOOK_KNL :: HOOK {
    param Order :: 1
    param iComment :: "Used to support TSK function hooks (cannot be deleted)"
    param iIsUsed :: 0
    param iDelUser :: "HOOK"
    param iDelMsg :: "This hook instance is used by TSK and cannot be deleted"
    param initFxn :: @_FXN_F_nop
    param createFxn :: TSK.CREATEFXN
    param deleteFxn :: TSK.DELETEFXN
    param exitFxn :: TSK.EXITFXN
    param callSwitchFxn :: TSK.DOSWITCH
    param switchFxn :: TSK.VSWFXN
    param callReadyFxn :: TSK.DOREADY
    param readyFxn :: TSK.VRDYFXN
}
